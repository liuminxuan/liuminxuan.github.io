<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【小项目】Java实现带编译器和解释器的计算器</title>
    <link href="/2021/01/28/%E3%80%90%E5%B0%8F%E9%A1%B9%E7%9B%AE%E3%80%91Java%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    <url>/2021/01/28/%E3%80%90%E5%B0%8F%E9%A1%B9%E7%9B%AE%E3%80%91Java%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>本项目通过Java写的语法树和虚拟机对variable实现简单的计算器操作，实现的功能如下图所示</p><p><img src="https://raw.githubusercontent.com/liuminxuan/PicRepo/main/StateDiagramOfAssignCalculator.png" alt="StateDiagramOfAssignCalculator"></p><h1 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h1><p>计算机语言可以有两种执行方式：</p><ol><li>先编译成机器码，再执行。</li><li>边解释边执行。</li></ol><p>我们常见的C和C++是通过先编译再执行，而 python可以边解释边执行。Java语言比较特殊，会对热点代码进行编译，编译和解释混用。</p><p>编译器和解释器区别如下：</p><ol><li>解释器可以运行同时翻译程序。编译器先扫描整个程序然后将程序翻译成机器码。</li><li>解释器可以用较少的时间分析程序，但是运行时间比编译器长。编译器需要较长的时间去分析程序，但是可以以较快的速度运行。</li><li>解释器不会生成临时的对象码，所以可以更好利用内存。编译器需要生成临时的文件去获取机器码关联，所以需要更多的内存。</li></ol><h1 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h1><p>要了解程序语言运行的先后顺序，语法树是必要的。比如当计算器遇到“+”时，就生成了以“+”为根结点的二叉树，左右节点分别是数字；又比如当计算器遇到“;”的时候，就生成了以“;”为根结点的语法树，左边为上一个表达式，右边为下一个表达式。</p><p>比如我们想计算如下算式：</p><div class="hljs code-wrapper"><pre><code class="hljs gml"><span class="hljs-symbol">x</span> := <span class="hljs-number">-2</span>;<span class="hljs-symbol">x</span> := <span class="hljs-number">-2</span>*<span class="hljs-symbol">x</span>;<span class="hljs-symbol">x</span> := <span class="hljs-number">-2</span>*<span class="hljs-symbol">x</span>;</code></pre></div><p>我们得到了如下所示的语法树：<br><img src="https://raw.githubusercontent.com/liuminxuan/PicRepo/main/ObjectDiagramOfAssignCalculator.png" alt="ObjectDiagramOfAssignCalculator"></p><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><p>虚拟机通过读取语法树里的节点，进而对节点进行处理，从而输出结果，本项目中的虚拟机通过Map和Stack实现数字的加减乘除。</p><p>项目地址：<a href="https://github.com/liuminxuan/LanguageProcessor">点此进入</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】默认方法</title>
    <link href="/2020/12/21/%E3%80%90Java%E5%AD%A6%E4%B9%A0%E3%80%91%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/"/>
    <url>/2020/12/21/%E3%80%90Java%E5%AD%A6%E4%B9%A0%E3%80%91%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是默认方法"><a href="#什么是默认方法" class="headerlink" title="什么是默认方法"></a>什么是默认方法</h1><p>默认方法是JDK8新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法。</p><h1 id="为什么会有默认方法"><a href="#为什么会有默认方法" class="headerlink" title="为什么会有默认方法"></a>为什么会有默认方法</h1><p>原来的类不用改动就都能得到相同的一种方法。可以方便扩展新的类，而且不影响别的类。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>当一个类实现两个接口并且两个接口中有相同的默认方法时，必须在类中override默认方法。要不然编译器无法判断使用谁的默认方法。</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">/*AD.java*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AD</span> </span>&#123;    <span class="hljs-comment">//物理伤害</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">physicAttack</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attack</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;default method attack&quot;</span>);    &#125;&#125;<span class="hljs-comment">/*AP.java*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AP</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">magicAttack</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attack</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;default method attack&quot;</span>);    &#125;&#125;<span class="hljs-comment">/*ADAPHero.java*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ADAPHero</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Hero</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AP</span>,<span class="hljs-title">AD</span>,<span class="hljs-title">Mortal</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">physicAttack</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;进行物理攻击&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">magicAttack</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;进行魔法攻击&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">die</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(name +<span class="hljs-string">&quot; is an APADHero and die.&quot;</span>);    &#125;    <span class="hljs-comment">// 必须重写该方法才不会报错</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attack</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;ADAP attack&quot;</span>);    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【小项目】爬取J-stage论文信息的爬虫</title>
    <link href="/2020/12/10/%E7%88%AC%E5%8F%96J-stage%E8%AE%BA%E6%96%87%E4%BF%A1%E6%81%AF%E7%9A%84%E7%88%AC%E8%99%AB/"/>
    <url>/2020/12/10/%E7%88%AC%E5%8F%96J-stage%E8%AE%BA%E6%96%87%E4%BF%A1%E6%81%AF%E7%9A%84%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<p>最近接了一个活，需要爬取日本论文网站的论文信息并且把对应的论文全部下载下来。对于这种重复劳动，计算机的学生当然不会手动一个一个下载，所以临时学了一点爬虫，照着写了一个小代码。</p><h1 id="设计爬虫"><a href="#设计爬虫" class="headerlink" title="设计爬虫"></a>设计爬虫</h1><p>因为日本没有类似中国知网这种官方论文网站，所以我就选取了<a href="https://www.jstage.jst.go.jp/browse/-char/ja">J-stage</a>作为这次爬虫的目标网站。<a href="https://www.jstage.jst.go.jp/browse/-char/ja">J-stage</a>上面的论文几乎免费，在日本范围内是很好的论文检索网站。  </p><p>要求爬取论文题目，作者所属机关，作者名，发表年月，几卷几号多少页，输出成Excel表格，顺便下载已经爬取的论文。</p><p>一开始想用Selenium库来爬取，因为看上去和手动操作极度类似，但是Selenium库存在代码不易编写的问题，而且Selenium作为一个网页测试工具，运行速度也成问题。所以转而用普遍方法Request。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>本代码是基于网上爬取豆瓣电影的代码修改而成，其中部分细节借鉴了Github上的<a href="https://github.com/nagomiso/jstage-spider">jstage-spider</a>项目。在此表示感谢。</p><p>因为主要架构大体相同，不同的杂志只需要修改URL和卷号就行，所以本代码以爬取コンピュータ＆エデュケーション杂志为例。</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">  function:爬取j-stage（コンピュータ＆エデュケーション）杂志论文，并写入Excel文件</span><span class="hljs-string">  env:python3.6.5</span><span class="hljs-string">  author:lmx</span><span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> requests<span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> workbook  <span class="hljs-comment"># 写入Excel表所用</span><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup <span class="hljs-keyword">as</span> bs<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Jstage</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-comment">#起始地址</span>        self.start_url = <span class="hljs-string">&#x27;https://www.jstage.jst.go.jp/browse/konpyutariyoukyouiku/&#x27;</span> <span class="hljs-comment">#url前半部分不变，只需修改最后数字</span>        <span class="hljs-comment">#请求头，浏览器模拟</span>        self.headers = &#123;            <span class="hljs-string">&#x27;User-Agent&#x27;</span>:<span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36&#x27;</span>,        &#125;        <span class="hljs-comment">#本卷有多少号</span>        self.page_num = <span class="hljs-number">48</span>    <span class="hljs-string">&#x27;&#x27;&#x27;url拼接&#x27;&#x27;&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_page_url</span>(<span class="hljs-params">self</span>):</span>        n = <span class="hljs-number">47</span> <span class="hljs-comment">#第一页开始,下标0</span>        <span class="hljs-keyword">while</span> n&lt;self.page_num:            <span class="hljs-keyword">yield</span> self.start_url+ str(n) + <span class="hljs-string">&#x27;/0/_contents/-char/ja&#x27;</span>            n += <span class="hljs-number">1</span>    <span class="hljs-string">&#x27;&#x27;&#x27;获取页面源码&#x27;&#x27;&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getHtml</span>(<span class="hljs-params">self</span>):</span>        gu = self.get_page_url() <span class="hljs-comment">#url生成器</span>        <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> gu:            html = requests.get(url,headers=self.headers).text            <span class="hljs-keyword">yield</span> html    <span class="hljs-string">&#x27;&#x27;&#x27;数据提取&#x27;&#x27;&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getData</span>(<span class="hljs-params">self</span>):</span>        gh = self.getHtml() <span class="hljs-comment"># html源码生成器</span>        <span class="hljs-keyword">for</span> html <span class="hljs-keyword">in</span> gh: <span class="hljs-comment"># html:网页源码</span>            soup = bs(html, <span class="hljs-string">&#x27;html.parser&#x27;</span>)            <span class="hljs-comment">#tmp = soup.find_all(&#x27;ul&#x27;, class_=&#x27;search-resultslisting&#x27;) # 辅助定位</span>            <span class="hljs-keyword">for</span> ul <span class="hljs-keyword">in</span> soup.find_all(<span class="hljs-string">&#x27;ul&#x27;</span>, class_=<span class="hljs-string">&#x27;search-resultslisting&#x27;</span>):                <span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> ul.find_all(<span class="hljs-string">&#x27;li&#x27;</span>):                    <span class="hljs-comment"># 标题</span>                    title = li.find(<span class="hljs-string">&#x27;div&#x27;</span>,class_=<span class="hljs-string">&#x27;searchlist-title&#x27;</span>).text.strip()                    <span class="hljs-comment"># 找到标题内部的链接，跳转进去</span>                    title_url = li.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;searchlist-title&#x27;</span>).find(<span class="hljs-string">&#x27;a&#x27;</span>).get(<span class="hljs-string">&#x27;href&#x27;</span>)                    <span class="hljs-comment"># 将详情页转为html</span>                    title_html = requests.get(title_url).text                    soup = bs(title_html, <span class="hljs-string">&#x27;html.parser&#x27;</span>)                    <span class="hljs-comment"># 找到作者所在研究机关</span>                    <span class="hljs-keyword">try</span>:                        institution = soup.find(<span class="hljs-string">&#x27;ul&#x27;</span>, class_=<span class="hljs-string">&#x27;accodion_body_ul&#x27;</span>).find(<span class="hljs-string">&#x27;li&#x27;</span>).find(<span class="hljs-string">&#x27;p&#x27;</span>).text.strip()                    <span class="hljs-keyword">except</span>:                        institution = <span class="hljs-string">&quot;none&quot;</span>                    <span class="hljs-comment"># 查找论文keyword</span>                    <span class="hljs-keyword">try</span>:                        pre_keyword = soup.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;global-para&#x27;</span>).text.strip()                        pre_keyword = pre_keyword.replace(<span class="hljs-string">&#x27;\u2003&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;\u3000&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;\t&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).strip()                    <span class="hljs-keyword">except</span>:                        pre_keyword = <span class="hljs-string">&quot;none:none&quot;</span>                    <span class="hljs-comment"># 对keyword进行分割，只留关键信息</span>                    <span class="hljs-keyword">try</span>:                        pre_keyword = pre_keyword.split(<span class="hljs-string">&quot;:&quot;</span>,<span class="hljs-number">1</span>)                        pre, keyword = pre_keyword[<span class="hljs-number">0</span>],pre_keyword[<span class="hljs-number">1</span>]                    <span class="hljs-keyword">except</span>:                        keyword = <span class="hljs-string">&quot;none&quot;</span>                    <span class="hljs-comment"># 在搜索页查找作者名，发表年份，几卷几号，第几页</span>                    <span class="hljs-keyword">try</span>:                        author = li.find(<span class="hljs-string">&#x27;div&#x27;</span>,class_=<span class="hljs-string">&#x27;searchlist-authortags customTooltip&#x27;</span>).text.strip()                        info = li.find(<span class="hljs-string">&#x27;div&#x27;</span>,class_=<span class="hljs-string">&#x27;searchlist-additional-info&#x27;</span>).text.strip()                        info = info.replace(<span class="hljs-string">&#x27;\u2003&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;\u3000&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;\t&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).strip()                        info = info.split(<span class="hljs-string">&quot;年&quot;</span>,<span class="hljs-number">1</span>)                        year, rem = info[<span class="hljs-number">0</span>],info[<span class="hljs-number">1</span>]                        rem = rem.split(<span class="hljs-string">&quot;p.&quot;</span>,<span class="hljs-number">1</span>)                        vol, page = rem[<span class="hljs-number">0</span>],rem[<span class="hljs-number">1</span>]                        page = page.split(<span class="hljs-string">&quot;発&quot;</span>,<span class="hljs-number">1</span>)                        page = page[<span class="hljs-number">0</span>]                    <span class="hljs-keyword">except</span>:                        print(title + <span class="hljs-string">&quot;,未能收集&quot;</span>)                        author = <span class="hljs-string">&quot;no author&quot;</span>                        year = <span class="hljs-string">&quot;no year&quot;</span>                        vol = <span class="hljs-string">&quot;no vol&quot;</span>                        page = <span class="hljs-string">&quot;no page&quot;</span>                    <span class="hljs-comment"># 查找概要</span>                    <span class="hljs-keyword">try</span>:                        abstract = li.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;inner-content abstract&#x27;</span>).text.strip()                        abstract = abstract.replace(<span class="hljs-string">&#x27;\u2003&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;\u3000&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;\t&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).strip()                    <span class="hljs-keyword">except</span>:                        abstract = <span class="hljs-string">&quot;none. 抄録全体を表示&quot;</span>                    abstract = abstract.split(<span class="hljs-string">&quot;抄録全体&quot;</span>, <span class="hljs-number">1</span>)                    abstract = abstract[<span class="hljs-number">0</span>]                    <span class="hljs-comment"># 执行论文pdf下载</span>                    pre_file_url = li.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;lft&#x27;</span>).find(<span class="hljs-string">&#x27;span&#x27;</span>).find(<span class="hljs-string">&#x27;a&#x27;</span>)                    file_url = pre_file_url.get(<span class="hljs-string">&#x27;href&#x27;</span>)                    print(file_url)                    <span class="hljs-keyword">try</span>:                        r = requests.get(file_url, stream=<span class="hljs-literal">True</span>)                        <span class="hljs-keyword">with</span> open(<span class="hljs-string">&quot;[&quot;</span> + vol + <span class="hljs-string">&quot;]&quot;</span> + page + <span class="hljs-string">&quot;.pdf&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> pdf:                            <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> r.iter_content(chunk_size=<span class="hljs-number">1024</span>):                                <span class="hljs-keyword">if</span> chunk:                                    pdf.write(chunk)                        print(<span class="hljs-string">&quot;完成收集:&quot;</span> + title)                    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:                        print(<span class="hljs-string">&quot;------------------------------------------------未能下载:&quot;</span> + title)                        print(<span class="hljs-string">&quot;原因:%s&quot;</span>%e)                    <span class="hljs-comment"># 对服务器仁慈</span>                    time.sleep(<span class="hljs-number">15</span>)                    <span class="hljs-keyword">yield</span> [author, institution, title, keyword, year, vol, page, abstract]    <span class="hljs-string">&#x27;&#x27;&#x27;保存到excel文件</span><span class="hljs-string">    :param file_name:文件名</span><span class="hljs-string">    &#x27;&#x27;&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">saveToExcel</span>(<span class="hljs-params">self,file_name</span>):</span>        wb = workbook.Workbook()  <span class="hljs-comment"># 创建Excel对象</span>        ws = wb.active  <span class="hljs-comment"># 获取当前正在操作的表对象</span>        ws.append([<span class="hljs-string">&#x27;author&#x27;</span>, <span class="hljs-string">&#x27;institution&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;keyword&#x27;</span>, <span class="hljs-string">&#x27;year&#x27;</span>, <span class="hljs-string">&#x27;vol&#x27;</span>, <span class="hljs-string">&#x27;page&#x27;</span>, <span class="hljs-string">&#x27;abstract&#x27;</span>])        gd = self.getData() <span class="hljs-comment">#数据生成器</span>        <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> gd:            ws.append(data)        wb.save(file_name)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    start = time.time()    top = Jstage()    <span class="hljs-keyword">try</span>:        top.saveToExcel(<span class="hljs-string">&#x27;computer_edu.xlsx&#x27;</span>)        print(<span class="hljs-string">&#x27;抓取成功,用时%4.2f&#x27;</span>%(time.time()-start)+<span class="hljs-string">&#x27;秒&#x27;</span>)    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        print(<span class="hljs-string">&#x27;抓取失败,原因:%s&#x27;</span>%e)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>一些小项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】抽象类和接口的区别</title>
    <link href="/2020/12/07/%E3%80%90Java%E5%AD%A6%E4%B9%A0%E3%80%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/12/07/%E3%80%90Java%E5%AD%A6%E4%B9%A0%E3%80%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="区别1："><a href="#区别1：" class="headerlink" title="区别1："></a>区别1：</h1><p>子类只能继承一个抽象类，不能继承多个<br>子类可以实现<strong>多个</strong>接口</p><h1 id="区别2："><a href="#区别2：" class="headerlink" title="区别2："></a>区别2：</h1><p>抽象类可以定义<br>public,protected,package,private<br>静态和非静态属性<br>final和非final属性<br>但是接口中声明的属性，只能是<br>public<br>静态<br>final的<br>即便没有显式的声明</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】== 和equals()</title>
    <link href="/2020/11/30/%E3%80%90Java%E5%AD%A6%E4%B9%A0%E3%80%91-%E5%92%8Cequals/"/>
    <url>/2020/11/30/%E3%80%90Java%E5%AD%A6%E4%B9%A0%E3%80%91-%E5%92%8Cequals/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title="=="></a>==</h1><p>“==” 用于判断两个引用是否指向同一个对象。准确说是判断两个引用指向的地址是否相同。</p><h1 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h1><p>“equals”用于判断两个对象的内容是否相同<br>如果对象里面的属性以及方法的值完全相同，那两个对象就相等。</p><h1 id="String类型比较"><a href="#String类型比较" class="headerlink" title="String类型比较"></a>String类型比较</h1><p>每次创建一个String对象都是创建一个新的对象，但是创建的时候如果String不是很长，Java会在已创建的String对象里寻找相同的对象然后指向它。</p><p>但是当String非常长的时候，Java会直接创建对象，所以比较两个String对象的时候，不要用”==”,要用equals方法。</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】静态方法（类方法）</title>
    <link href="/2020/11/24/%E3%80%90Java%E5%AD%A6%E4%B9%A0%E3%80%91%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%88%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%89/"/>
    <url>/2020/11/24/%E3%80%90Java%E5%AD%A6%E4%B9%A0%E3%80%91%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%88%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h1><p>类方法： 又叫做静态方法</p><p>对象方法： 又叫实例方法，非静态方法</p><p>访问一个对象方法，必须<strong>建立在有一个对象</strong>的前提的基础上<br>访问类方法，<strong>不需要对象的存在</strong>，直接就访问</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hero</span> </span>&#123;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">float</span> hp;     <span class="hljs-comment">//实例方法,对象方法，非静态方法</span>    <span class="hljs-comment">//必须有对象才能够调用</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">die</span><span class="hljs-params">()</span></span>&#123;        hp = <span class="hljs-number">0</span>;    &#125;         <span class="hljs-comment">//类方法，静态方法</span>    <span class="hljs-comment">//通过类就可以直接调用</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">battleWin</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;battle win&quot;</span>);    &#125;         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;           Hero garen =  <span class="hljs-keyword">new</span> Hero();           garen.name = <span class="hljs-string">&quot;盖伦&quot;</span>;           <span class="hljs-comment">//必须有一个对象才能调用</span>           garen.die();                       Hero teemo =  <span class="hljs-keyword">new</span> Hero();           teemo.name = <span class="hljs-string">&quot;提莫&quot;</span>;                       <span class="hljs-comment">//无需对象，直接通过类调用</span>           Hero.battleWin();             &#125;&#125;</code></pre></div><h1 id="调用类方法"><a href="#调用类方法" class="headerlink" title="调用类方法"></a>调用类方法</h1><p><code>Math.random()</code>就是一种（静态方法）类方法的调用。</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】静态属性（类属性）</title>
    <link href="/2020/11/19/%E3%80%90Java%E5%AD%A6%E4%B9%A0%E3%80%91%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/"/>
    <url>/2020/11/19/%E3%80%90Java%E5%AD%A6%E4%B9%A0%E3%80%91%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>当一个属性被<strong>static</strong>修饰的时候，就叫做<strong>类属性</strong>，又叫做<strong>静态属性</strong><br>当一个属性被声明成类属性，<strong>那么所有的对象，都共享一个值</strong></p><h1 id="类属性和对象属性"><a href="#类属性和对象属性" class="headerlink" title="类属性和对象属性"></a>类属性和对象属性</h1><p><strong>类属性</strong>： 又叫做静态属性<br><strong>对象属性</strong>： 又叫实例属性，非静态属性<br>如果一个属性声明成类属性，那么所有的对象，都共享这么一个值<br>给英雄设置一个类属性叫做“版权” (copyright), 无论有多少个具体的英雄，所有的英雄的版权都属于 Riot Games公司。</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> charactor; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hero</span> </span>&#123;    <span class="hljs-keyword">public</span> String name; <span class="hljs-comment">//实例属性，对象属性，非静态属性</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">float</span> hp;    <span class="hljs-keyword">static</span> String copyright;<span class="hljs-comment">//类属性,静态属性</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;           Hero garen =  <span class="hljs-keyword">new</span> Hero();           garen.name = <span class="hljs-string">&quot;盖伦&quot;</span>;                       Hero.copyright = <span class="hljs-string">&quot;版权由Riot Games公司所有&quot;</span>;                       System.out.println(garen.name);           System.out.println(garen.copyright);                       Hero teemo =  <span class="hljs-keyword">new</span> Hero();           teemo.name = <span class="hljs-string">&quot;提莫&quot;</span>;           System.out.println(teemo.name);               System.out.println(teemo.copyright);             &#125;     &#125;</code></pre></div><h1 id="访问类属性"><a href="#访问类属性" class="headerlink" title="访问类属性"></a>访问类属性</h1><ol><li><code>teemo.copyright</code></li><li><code>Hero.copyright</code></li></ol><h1 id="什么时候使用对象属性，什么时候使用类属性"><a href="#什么时候使用对象属性，什么时候使用类属性" class="headerlink" title="什么时候使用对象属性，什么时候使用类属性"></a>什么时候使用对象属性，什么时候使用类属性</h1><p>如果一个属性，每个英雄都不一样，比如name，这样的属性就应该设计为对象属性，因为<strong>它是跟着对象走的</strong>，每个对象的name都是不同的</p><p>如果一个属性，<strong>所有的英雄都共享</strong>，都是一样的，那么就应该设计为类属性。比如血量上限，所有的英雄的血量上限都是 9999，不会因为英雄不同，而取不同的值。 这样的属性，就适合设计为类属性</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】常见异常以及异常分类</title>
    <link href="/2020/10/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%BC%82%E5%B8%B8%E4%BB%A5%E5%8F%8A%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BBchecked-exception%E5%92%8Cunchecked-expception/"/>
    <url>/2020/10/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%BC%82%E5%B8%B8%E4%BB%A5%E5%8F%8A%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BBchecked-exception%E5%92%8Cunchecked-expception/</url>
    
    <content type="html"><![CDATA[<h1 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h1><table><thead><tr><th>类别</th><th>常见异常</th></tr></thead><tbody><tr><td>Error</td><td>AssertionError、OutOfMemoryError、StackOverflowError</td></tr><tr><td>UncheckedException</td><td>AlreadyBoundException、ClassCastException、ConcurrentModificationException、IllegalArgumentException、IllegalStateException、IndexOutOfBoundsException、JSONException、NullPointerException、SecurityException、UnsupportedOperationException｜</td></tr><tr><td>CheckedException</td><td>ClassNotFoundException、CloneNotSupportedException、FileAlreadyExistsException、FileNotFoundException、InterruptedException、IOException、SQLException、TimeoutException、UnknownHostException</td></tr></tbody></table><h1 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h1><p><strong>Error通常描述了系统级的错误，并且程序猿无法主动处理</strong>——当然，系统级错误也有可能由代码间接导致，这不在我们的讨论范围内。发生系统级错误的时候，系统环境已经不健康了，因此，Error不强制捕获或声明，也就是<strong>不强制处理，一般情况下只需要把异常信息记录下来</strong>（如果能记下当时的系统快照更好）。</p><h1 id="Unchecked-Exception"><a href="#Unchecked-Exception" class="headerlink" title="Unchecked Exception"></a>Unchecked Exception</h1><p>严格来说，Error也可以被划归UncheckedException，但我们更习惯用<strong>UncheckedException描述运行期发生，通常由于代码问题直接引起的程序相关的错误，并且程序猿无法主动处理</strong>。注意区分，系统级错误都应该用Error描述。UncheckedException发生的大部分情况是代码写挫了，因此，UncheckedException也不强制捕获或声明，也就是<strong>不强制处理，一般情况下记下日志即可</strong>。</p><p>不同的是，如果可能，<strong>要保证UncheckedException是可控的（在异常被动抛出前检查并主动抛出）</strong>。</p><h1 id="Checked-Expception"><a href="#Checked-Expception" class="headerlink" title="Checked Expception"></a>Checked Expception</h1><p><strong>CheckedException描述了外部环境导致的不太严重的错误，程序猿应该主动处理</strong>。注意与系统级错误区分，系统级错误通常是不可恢复的。因此，CheckedException强制捕获或声明，程序猿必须处理。<strong>记录日志，包装后再次抛出，在方法签名中声明</strong>，是三种最常见的做法。</p><p>同UncheckedException一样，<strong>CheckedException也要保证是可控的</strong>。对CheckedException的可控性要求更高，不仅要主动检查，还要在捕获到异常时，作出合适的处理。</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】枚举</title>
    <link href="/2020/10/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9E%9A%E4%B8%BE/"/>
    <url>/2020/10/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="Java枚举"><a href="#Java枚举" class="headerlink" title="Java枚举"></a>Java枚举</h1><p>Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。<br>Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 , 来分割。</p><h1 id="例如定义一个颜色的枚举类"><a href="#例如定义一个颜色的枚举类" class="headerlink" title="例如定义一个颜色的枚举类"></a>例如定义一个颜色的枚举类</h1><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">enum</span> Color &#123;     RED, GREEN, BLUE; &#125;</code></pre></div><p>实例：</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">enum</span> Color&#123;    RED, GREEN, BLUE;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-comment">// 执行输出结果</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>&#123;        Color c1 = Color.RED;        System.out.println(c1);    &#125;&#125;</code></pre></div><p>执行结果</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">RED</span></code></pre></div><h1 id="迭代枚举元素"><a href="#迭代枚举元素" class="headerlink" title="迭代枚举元素"></a>迭代枚举元素</h1><p>可以使用 for 语句来迭代枚举元素：</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">enum</span> Color&#123;    RED, GREEN, BLUE;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">for</span> (Color myVar : Color.values()) &#123;      System.out.println(myVar);    &#125;  &#125;&#125;</code></pre></div><p>输出结果</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">RED</span><span class="hljs-attribute">GREEN</span><span class="hljs-attribute">BLUE</span></code></pre></div><h1 id="在switch中使用枚举类"><a href="#在switch中使用枚举类" class="headerlink" title="在switch中使用枚举类"></a>在switch中使用枚举类</h1><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">enum</span> Color&#123;    RED, GREEN, BLUE;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Color myVar = Color.BLUE;    <span class="hljs-keyword">switch</span>(myVar) &#123;      <span class="hljs-keyword">case</span> RED:        System.out.println(<span class="hljs-string">&quot;红色&quot;</span>);        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> GREEN:         System.out.println(<span class="hljs-string">&quot;绿色&quot;</span>);        <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> BLUE:        System.out.println(<span class="hljs-string">&quot;蓝色&quot;</span>);        <span class="hljs-keyword">break</span>;    &#125;  &#125;&#125;</code></pre></div><p>结果为<code>蓝色</code></p><h1 id="values-ordinal-和-valueOf-方法"><a href="#values-ordinal-和-valueOf-方法" class="headerlink" title="values(), ordinal() 和 valueOf() 方法"></a>values(), ordinal() 和 valueOf() 方法</h1><p>enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。<br>values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：</p><ul><li>values() 返回枚举类中所有的值。</li><li>ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。</li><li>valueOf()方法返回指定字符串值的枚举常量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】HashMap和HashTable</title>
    <link href="/2020/10/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AHashMap%E5%92%8CHashTable/"/>
    <url>/2020/10/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AHashMap%E5%92%8CHashTable/</url>
    
    <content type="html"><![CDATA[<ol><li><p>Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。</p></li><li><p>HashMap是非线程安全的，HashTable是线程安全的。</p></li><li><p>HashMap的键和值都允许有null值存在(允许一个)，而HashTable则不行。</p></li><li><p>因为线程安全的问题，HashMap效率比HashTable的要高。</p></li><li><p>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。</p><p> 一般现在<strong>不建议用HashTable</strong>, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有<strong>同步的ConcurrentHashMap</strong>替代，没有必要因为是多线程而用HashTable。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】21. 调整数组顺序使奇数位于偶数前面</title>
    <link href="/2020/09/04/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <url>/2020/09/04/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer刷题笔记：21-调整数组顺序使奇数位于偶数前面"><a href="#剑指offer刷题笔记：21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指offer刷题笔记：21. 调整数组顺序使奇数位于偶数前面"></a>剑指offer刷题笔记：21. 调整数组顺序使奇数位于偶数前面</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>] 注：[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>] 也是正确的答案之一。</code></pre></div><h2 id="解题思路1-头尾指针"><a href="#解题思路1-头尾指针" class="headerlink" title="解题思路1 头尾指针"></a>解题思路1 头尾指针</h2><p>记录这题是因为这是最近leetcode第一道没有出现错误一气呵成的题目，算是一个小小的里程碑吧。虽然很简单，但是给了我信心哈哈。<br>算法很简单，首先创建一个新数组，然后遍历原数组，遇到奇数放到头上，遇到偶数放到尾巴上。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] exchange(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-comment">// new一个新数组</span>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];        <span class="hljs-comment">// 确定新数组的头和尾的位置</span>        <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> t = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-comment">// 遍历nums，如果为奇数则放入新数组头的位置，否则放入新数组尾巴的位置</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;            <span class="hljs-keyword">if</span>(nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;                res[h] = nums[i];                h++;            &#125;<span class="hljs-keyword">else</span>&#123;                res[t] = nums[i];                t--;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h2 id="解题思路2-原数组上交换"><a href="#解题思路2-原数组上交换" class="headerlink" title="解题思路2 原数组上交换"></a>解题思路2 原数组上交换</h2><p>因为解题思路1的内存消耗较大，所以想到在原数组上互换。<br>结果内存消耗从49.4MB变为47.6MB，超越人数从2%提升到90%。<br>但是执行用时从超越99%的2ms变为超越34.3%的3ms。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] exchange(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> tail = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-comment">// if-else的顺序十分巧妙</span>        <span class="hljs-comment">// 先判断头尾是否符合要求，如果前两个if都走完了说明两个都不符合要求，则互换</span>        <span class="hljs-keyword">while</span>(head &lt;= tail)&#123;            <span class="hljs-keyword">if</span>(nums[head] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;                head++;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[tail] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;                tail--;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">int</span> tmp = nums[head];                nums[head] = nums[tail];                nums[tail] = tmp;                head++;                tail--;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>剑指offer刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】18. 删除链表的节点</title>
    <link href="/2020/09/03/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2020/09/03/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。<br><strong>注意</strong>：此题对比原题有改动</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入: head = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>], val = <span class="hljs-number">5</span>输出: [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>]解释: 给定你链表中值为 <span class="hljs-number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="hljs-number">4</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">9.</span></code></pre></div><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入: head = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>], val = <span class="hljs-number">1</span>输出: [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]解释: 给定你链表中值为 <span class="hljs-number">1</span> 的第三个节点，那么在调用了你的函数之后，该链表应变为 <span class="hljs-number">4</span> -&gt; <span class="hljs-number">5</span> -&gt; <span class="hljs-number">9.</span></code></pre></div><h2 id="解题思路1-双指针"><a href="#解题思路1-双指针" class="headerlink" title="解题思路1 双指针"></a>解题思路1 双指针</h2><p>Leetcode上大多数关于链表的题目都可以用双指针来解决，此题也不例外。<br>前指针记录前一个节点，现指针记录现在的节点，这样当现指针找到对应节点时直接让前指针指向现指针之后的节点。<br>注意当第一个节点为要找的节点时直接返回第二个节点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head.val == val) <span class="hljs-keyword">return</span> head.next; <span class="hljs-comment">// 如果头节点的值等于val，直接返回头节点的下一个</span>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>); <span class="hljs-comment">// 取出头节点，最后好直接返回</span>        dummy.next = head;        <span class="hljs-comment">// 双指针法，俩指针一前一后</span>        ListNode pre = head;        ListNode cur = head.next;        <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span>(cur.val == val)&#123;                pre.next = cur.next;                <span class="hljs-keyword">break</span>;            &#125;            cur = cur.next;            pre = pre.next;        &#125;        <span class="hljs-keyword">return</span> dummy.next;    &#125;&#125;</code></pre></div><h2 id="解题思路2-单指针"><a href="#解题思路2-单指针" class="headerlink" title="解题思路2 单指针"></a>解题思路2 单指针</h2><p>因为此题如果使用双指针，两个指针永远是一前一后，所以可以用head和head.next来代替双指针。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head.val == val) <span class="hljs-keyword">return</span> head.next; <span class="hljs-comment">// 如果头节点的值等于val，直接返回头节点的下一个</span>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>); <span class="hljs-comment">// 取出头节点，最后好直接返回</span>        dummy.next = head;        <span class="hljs-keyword">while</span>(head.next != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span>(head.next.val == val)&#123;                head.next = head.next.next;                <span class="hljs-keyword">break</span>;            &#125;            head = head.next;        &#125;        <span class="hljs-keyword">return</span> dummy.next;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>剑指offer刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】39. 数组中出现次数超过一半的数字</title>
    <link href="/2020/09/02/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B039-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/09/02/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B039-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39. 数组中出现次数超过一半的数字"></a>39. 数组中出现次数超过一半的数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>]输出: <span class="hljs-number">2</span></code></pre></div><h2 id="解题思路1-排序"><a href="#解题思路1-排序" class="headerlink" title="解题思路1 排序"></a>解题思路1 排序</h2><p>因为需要的数字出现次数多于一半，那么排序后必定在中间。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        Arrays.sort(nums);        <span class="hljs-keyword">return</span> nums[nums.length/<span class="hljs-number">2</span>];    &#125;&#125;</code></pre></div><h2 id="解题思路2-HashMap"><a href="#解题思路2-HashMap" class="headerlink" title="解题思路2 HashMap"></a>解题思路2 HashMap</h2><p>数数然后查找这种问题一定会想到HashMap，虽然执行效率不高，但是也算能出结果</p><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];        <span class="hljs-comment">// 移位运算高级写法</span>        <span class="hljs-comment">// int half = nums.length &gt;&gt; 1;</span>        <span class="hljs-keyword">int</span> half = nums.length / <span class="hljs-number">2</span>;        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;            <span class="hljs-comment">// 如果HashMap包含数组中的值，则先判断数量是否过半，如无过半，则数量加1</span>            <span class="hljs-comment">// 不包含则创建一个新的Key和值为1的count</span>            <span class="hljs-keyword">if</span>(map.containsKey(nums[i]))&#123;                <span class="hljs-keyword">int</span> count = map.get(nums[i]);                <span class="hljs-keyword">if</span>(++count &gt; half)&#123;                    <span class="hljs-keyword">return</span> nums[i];                &#125;                <span class="hljs-comment">// map.remove(nums[i]);</span>                map.put(nums[i], count);            &#125;<span class="hljs-keyword">else</span>&#123;                map.put(nums[i], <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div><h2 id="解题思路3-摩尔投票法"><a href="#解题思路3-摩尔投票法" class="headerlink" title="解题思路3 摩尔投票法"></a>解题思路3 摩尔投票法</h2><p>思想是将不同的数字互相消解，那最后余下的数字就是相同的数字。</p><blockquote><p>用target记录上一次访问的值，count表明当前值出现的次数，如果下一个值和当前值相同那么count++；如果不同count–，减到0的时候就要更换新的target值了，因为如果存在超过数组长度一半的值，那么最后target一定会是该值。可以这样理解，count的自加和自减就是在描述一种抵消关系，由于超过一半的出现次数，导致最后的target一定会是该值。（这种方法的时间复杂度自然会小些）</p></blockquote><h3 id="代码3"><a href="#代码3" class="headerlink" title="代码3"></a>代码3</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> target = nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始化为数组的第一个元素，接下来用于记录上一次访问的值</span>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用于记录出现次数</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;            <span class="hljs-keyword">if</span>(nums[i] == target)&#123;                count++;            &#125;<span class="hljs-keyword">else</span>&#123;                count--;            &#125;            <span class="hljs-comment">// 当count=0时，更换target的值为当前访问的数组元素的值，次数设为1</span>            <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)&#123;                target = nums[i];                count = <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> target;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>剑指offer刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】内部类</title>
    <link href="/2020/09/01/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>/2020/09/01/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="关于内部类"><a href="#关于内部类" class="headerlink" title="关于内部类"></a>关于内部类</h1><blockquote><p>内部类(inner class) : 定义在另一个类重的类</p></blockquote><p>为什么需要内部类？</p><ul><li>内部类方法可以访问该类定义所在作用域中的数据，包括被 private 修饰的私有数据</li><li>内部类可以对同一包中的其他类隐藏起来</li><li>内部类可以一定程度修复 java 单继承的缺陷</li><li>当我们想要定义一个回调函数却不想写大量代码的时候我们可以选择使用匿名内部类来实现</li></ul><h1 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h1><p>内部类可以分为：静态内部类（嵌套类）和非静态内部类。非静态内部类又可以分为：成员内部类、方法内部类、匿名内部类。</p><h2 id="静态内部类和非静态内部类的区别"><a href="#静态内部类和非静态内部类的区别" class="headerlink" title="静态内部类和非静态内部类的区别"></a>静态内部类和非静态内部类的区别</h2><ol><li>静态内部类可以有静态成员，而非静态内部类则不能有静态成员。</li><li>静态内部类可以访问外部类的静态变量，而不可访问外部类的非静态变量；</li><li>非静态内部类的非静态成员可以访问外部类的非静态变量。</li><li>静态内部类的创建不依赖于外部类，而非静态内部类必须依赖于外部类的创建而创建。</li></ol><p><strong>静态内部类</strong></p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassOuter</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> noStaticInt = <span class="hljs-number">1</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> STATIC_INT = <span class="hljs-number">2</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;外部类方法&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> </span>&#123;        <span class="hljs-comment">//static int num = 1; 此时编辑器会报错 非静态内部类则不能有静态成员</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;            <span class="hljs-comment">//非静态内部类的非静态成员可以访问外部类的非静态变量。</span>            System.out.println(STATIC_INT);            System.out.println(noStaticInt);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClass</span> </span>&#123;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> NUM = <span class="hljs-number">1</span>;<span class="hljs-comment">//静态内部类可以有静态成员</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;            System.out.println(STATIC_INT);            <span class="hljs-comment">//System.out.println(noStaticInt); 此时编辑器会报 不可访问外部类的非静态变量错</span>        &#125;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestInnerClass</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//非静态内部类 创建方式1</span>        ClassOuter.InnerClass innerClass = <span class="hljs-keyword">new</span> ClassOuter().<span class="hljs-function">new <span class="hljs-title">InnerClass</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">//非静态内部类 创建方式2</span>        ClassOuter outer = <span class="hljs-keyword">new</span> ClassOuter();        ClassOuter.InnerClass inner = outer.<span class="hljs-function">new <span class="hljs-title">InnerClass</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">//静态内部类的创建方式</span>        ClassOuter.StaticInnerClass staticInnerClass = <span class="hljs-keyword">new</span> ClassOuter.StaticInnerClass();    &#125;&#125;</code></pre></div><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。<br>在成员内部类中要注意两点：</p><ol><li>成员内部类中不能存在任何static的变量和方法，成员内部类里不能有静态内部类</li><li>成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类</li></ol><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;    <span class="hljs-keyword">private</span> String str;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outerDisplay</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;outerClass...&quot;</span>);    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span></span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">innerDisplay</span><span class="hljs-params">()</span></span>&#123;            <span class="hljs-comment">//使用外围内的属性</span>            str = <span class="hljs-string">&quot;inner...&quot;</span>;            System.out.println(str);            <span class="hljs-comment">//使用外围内的方法</span>            outerDisplay();        &#125;    &#125;        <span class="hljs-comment">/*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> InnerClass <span class="hljs-title">getInnerClass</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InnerClass();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        OuterClass outer = <span class="hljs-keyword">new</span> OuterClass();        OuterClass.InnerClass inner = outer.getInnerClass();        inner.innerDisplay();    &#125;&#125;--------------------innner...outerClass...</code></pre></div><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>定义在方法或作用域中的内部类，出了该方法，类就会失效。<br><strong>定义在方法中</strong></p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parcel5</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Destionation <span class="hljs-title">destionation</span><span class="hljs-params">(String str)</span></span>&#123;        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PDestionation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Destionation</span></span>&#123;            <span class="hljs-keyword">private</span> String label;            <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">PDestionation</span><span class="hljs-params">(String whereTo)</span></span>&#123;                label = whereTo;            &#125;            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readLabel</span><span class="hljs-params">()</span></span>&#123;                <span class="hljs-keyword">return</span> label;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PDestionation(str);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Parcel5 parcel5 = <span class="hljs-keyword">new</span> Parcel5();        Destionation d = parcel5.destionation(<span class="hljs-string">&quot;chenssy&quot;</span>);    &#125;&#125;</code></pre></div><p><strong>定义在作用域中</strong></p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parcel6</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">internalTracking</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b)</span></span>&#123;        <span class="hljs-keyword">if</span>(b)&#123;            <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrackingSlip</span></span>&#123;                <span class="hljs-keyword">private</span> String id;                TrackingSlip(String s) &#123;                    id = s;                &#125;                <span class="hljs-function">String <span class="hljs-title">getSlip</span><span class="hljs-params">()</span></span>&#123;                    <span class="hljs-keyword">return</span> id;                &#125;            &#125;            TrackingSlip ts = <span class="hljs-keyword">new</span> TrackingSlip(<span class="hljs-string">&quot;chenssy&quot;</span>);            String string = ts.getSlip();        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">track</span><span class="hljs-params">()</span></span>&#123;        internalTracking(<span class="hljs-keyword">true</span>);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Parcel6 parcel6 = <span class="hljs-keyword">new</span> Parcel6();        parcel6.track();    &#125;&#125;</code></pre></div><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名类实现接口和抽象类定义的抽象方法，快速创建一个抽象类的实例，可以出现在任何有代码的地方。</p><ol><li>匿名内部类是没有访问修饰符的。</li><li>匿名内部类必须继承一个抽象类或者实现一个接口</li><li>匿名内部类中不能存在任何静态成员或方法</li><li>匿名内部类是没有构造方法的，因为它没有类名。</li><li><strong>与局部内部相同匿名内部类也可以引用局部变量。此变量也必须声明为 final</strong></li></ol><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> InnerClass <span class="hljs-title">getInnerClass</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> num,String str2)</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InnerClass()&#123;            <span class="hljs-keyword">int</span> number = num + <span class="hljs-number">3</span>;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumber</span><span class="hljs-params">()</span></span>&#123;                <span class="hljs-keyword">return</span> number;            &#125;        &#125;;        <span class="hljs-comment">/* 注意：分号不能省 */</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        OuterClass out = <span class="hljs-keyword">new</span> OuterClass();        InnerClass inner = out.getInnerClass(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;chenssy&quot;</span>);        System.out.println(inner.getNumber());    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InnerClass</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getNumber</span><span class="hljs-params">()</span></span>;&#125;----------------Output:<span class="hljs-number">5</span></code></pre></div><h3 id="为什么局部变量需要final修饰呢"><a href="#为什么局部变量需要final修饰呢" class="headerlink" title="为什么局部变量需要final修饰呢"></a>为什么局部变量需要final修饰呢</h3><p>原因是：因为局部变量和匿名内部类的生命周期不同。<br>匿名内部类是创建后是存储在堆中的，而方法中的局部变量是存储在Java栈中，当方法执行完毕后，就进行退栈，同时局部变量也会消失。那么此时匿名内部类还有可能在堆中存储着，那么匿名内部类要到哪里去找这个局部变量呢？<br>为了解决这个问题编译器为自动地帮我们在匿名内部类中创建了一个局部变量的备份，也就是说即使方法执结束，匿名内部类中还有一个备份，自然就不怕找不到了。<br>但是问题又来了。如果局部变量中的a不停的在变化。那么岂不是也要让备份的a变量无时无刻的变化。为了保持局部变量与匿名内部类中备份域保持一致。编译器不得不规定死这些局部域必须是常量，一旦赋值不能再发生变化了。所以为什么匿名内部类应用外部方法的域必须是常量域的原因所在了。</p><p><strong>特别注意：在Java8中已经去掉要对final的修饰限制，但其实只要在匿名内部类使用了，该变量还是会自动变为final类型（只能使用，不能赋值）。</strong></p><h1 id="内部类会引起的问题"><a href="#内部类会引起的问题" class="headerlink" title="内部类会引起的问题"></a>内部类会引起的问题</h1><ol><li>如果一个匿名内部类没有被任何引用持有，那么匿名内部类对象用完就有机会被回收。</li><li>如果内部类仅仅只是在外部类中被引用，当外部类的不再被引用时，外部类和内部类就可以都被GC回收。</li><li>如果当内部类的引用被外部类以外的其他类引用时，就会造成内部类和外部类无法被GC回收的情况，即使外部类没有被引用，因为内部类持有指向外部类的引用）。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><ul><li><a href="https://juejin.im/post/6844903566293860366">https://juejin.im/post/6844903566293860366</a></li><li><a href="https://www.cnblogs.com/chenssy/p/3388487.html">https://www.cnblogs.com/chenssy/p/3388487.html</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】57. 和为s的两个数字</title>
    <link href="/2020/09/01/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A57/"/>
    <url>/2020/09/01/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A57/</url>
    
    <content type="html"><![CDATA[<h1 id="57-和为s的两个数字"><a href="#57-和为s的两个数字" class="headerlink" title="57. 和为s的两个数字"></a>57. 和为s的两个数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>], target = <span class="hljs-number">9</span>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">7</span>] 或者 [<span class="hljs-number">7</span>,<span class="hljs-number">2</span>]</code></pre></div><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><div class="hljs code-wrapper"><pre><code class="hljs angelscript">输入：nums = [<span class="hljs-number">10</span>,<span class="hljs-number">26</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">47</span>,<span class="hljs-number">60</span>], target = <span class="hljs-number">40</span>输出：[<span class="hljs-number">10</span>,<span class="hljs-number">30</span>] 或者 [<span class="hljs-number">30</span>,<span class="hljs-number">10</span>]</code></pre></div><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>看似简单，因为是升序数组，所以一开始用暴力求解，代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">int</span> s = target;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length; j++)&#123;                <span class="hljs-keyword">if</span>(nums[i] + nums[j] &lt; s)&#123;                    <span class="hljs-keyword">continue</span>;                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] + nums[j] &gt; s)&#123;                    <span class="hljs-keyword">break</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];                    res[<span class="hljs-number">0</span>] = nums[i];                    res[<span class="hljs-number">1</span>] = nums[j];                    <span class="hljs-keyword">return</span> res;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    &#125;&#125;</code></pre></div><p>结果超时了，转用HashMap求解。<br>首先当目标数组为空或只有一个值的时候，返回空。然后创建HashMap，遍历数组，将值放入HashMap，如果其中两个值相加可以得到目标值，则返回这两个值的结果。<br>遍历完依旧没有找到目标值，则返回空。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-comment">// 当数组为空或只有一个元素的时候，返回空</span>        <span class="hljs-keyword">if</span>(nums.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        <span class="hljs-comment">// 创建HashMap</span>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-comment">// 遍历数组，如果找到一个值可以与target - nums[i]对应，则返回结果</span>        <span class="hljs-comment">// 如果找不到对应，则把此值放入HashMap</span>        <span class="hljs-comment">// 遍历完成后如果没有返回结果则返回空</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;            <span class="hljs-keyword">int</span> cur = target - nums[i];            <span class="hljs-keyword">if</span>(map.containsKey(cur))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;cur, nums[i]&#125;;            &#125;            map.put(nums[i], i);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>剑指offer刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】接口</title>
    <link href="/2020/08/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%8E%A5%E5%8F%A3/"/>
    <url>/2020/08/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="关于接口"><a href="#关于接口" class="headerlink" title="关于接口"></a>关于接口</h2><p>接口是Java语言中的一个抽象类，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式来继承接口的抽象方法。<br><strong>接口不是类</strong>，编写接口的方式和类很相似，但是他们属于不同的概念。类描述对象的属性和方法，接口则包含类要实现的方法。<br><strong>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</strong><br>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><h3 id="接口与类的相似点"><a href="#接口与类的相似点" class="headerlink" title="接口与类的相似点"></a>接口与类的相似点</h3><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><h3 id="接口与类的区别"><a href="#接口与类的区别" class="headerlink" title="接口与类的区别"></a>接口与类的区别</h3><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口<strong>不能包含成员变量</strong>，除了 static 和 final 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul><h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><ul><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li></ul><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><ol><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</li><li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ol><h2 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h2><p>Interface关键字用来声明一个接口。下面是接口声明的一个简单实例。</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">/* 文件名 : Animal.java */</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Animal</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">travel</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>接口有以下特性：</p><ul><li>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。</li><li>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。</li><li>接口中的方法都是公有的。</li></ul><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。<br>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。<br>实例：</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">/* 文件名 : MammalInt.java */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MammalInt</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Animal</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;      System.out.println(<span class="hljs-string">&quot;Mammal eats&quot;</span>);   &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">travel</span><span class="hljs-params">()</span></span>&#123;      System.out.println(<span class="hljs-string">&quot;Mammal travels&quot;</span>);   &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">noOfLegs</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;      MammalInt m = <span class="hljs-keyword">new</span> MammalInt();      m.eat();      m.travel();   &#125;&#125;</code></pre></div><p>以上实例编译运行结果如下:</p><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">Mammal</span> <span class="hljs-string">eats</span><span class="hljs-attr">Mammal</span> <span class="hljs-string">travels</span></code></pre></div><p>重写接口中声明的方法时，需要注意以下规则：</p><ul><li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li><li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li><li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。<br>在实现接口的时候，也要注意一些规则：</li><li>一个类可以同时实现多个接口。</li><li>一个类只能继承一个类，但是能实现多个接口。</li><li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li></ul><h2 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h2><p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。<br>下面的Sports接口被Hockey和Football接口继承：</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">// 文件名: Sports.java</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Sports</span></span><span class="hljs-class"></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHomeTeam</span><span class="hljs-params">(String name)</span></span>;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVisitingTeam</span><span class="hljs-params">(String name)</span></span>;&#125; <span class="hljs-comment">// 文件名: Football.java</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Football</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sports</span></span><span class="hljs-class"></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">homeTeamScored</span><span class="hljs-params">(<span class="hljs-keyword">int</span> points)</span></span>;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitingTeamScored</span><span class="hljs-params">(<span class="hljs-keyword">int</span> points)</span></span>;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endOfQuarter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> quarter)</span></span>;&#125; <span class="hljs-comment">// 文件名: Hockey.java</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Hockey</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sports</span></span><span class="hljs-class"></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">homeGoalScored</span><span class="hljs-params">()</span></span>;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitingGoalScored</span><span class="hljs-params">()</span></span>;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endOfPeriod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> period)</span></span>;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overtimePeriod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ot)</span></span>;&#125;</code></pre></div><p>Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。<br>相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。</p><h2 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h2><p>在Java中，类的多继承是不合法，但接口允许多继承。<br>在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Hockey</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sports</span>, <span class="hljs-title">Event</span></span></code></pre></div><p>以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法</p><h2 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h2><p>最常用的继承接口是没有包含任何方法的接口。<br>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。<br>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。<br>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> java.util;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EventListener</span></span><span class="hljs-class"></span>&#123;&#125;</code></pre></div><p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p><ul><li><strong>建立一个公共的父接口</strong><br>  正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</li><li><strong>向一个类添加数据类型</strong><br>  这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】抽象类和抽象方法</title>
    <link href="/2020/08/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/"/>
    <url>/2020/08/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>Java是面向对象的语言，通过类来描述对象，但是如果一个类中没有足够的信息来描述对象，那么这个类就是抽象类。<br>抽象类<strong>不能被实例化</strong>,但是其他功能照常，成员变量、成员方法和构造方法和普通类一样。<br>由于抽象类不能被实例化，所以抽象类必须被继承后才能使用。<br>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。<br><strong>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</strong></p><h2 id="定义抽象类"><a href="#定义抽象类" class="headerlink" title="定义抽象类"></a>定义抽象类</h2><p>在Java语言中使用abstract class来定义抽象类。如下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">/* 文件名 : Employee.java */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>&#123;   <span class="hljs-keyword">private</span> String name;   <span class="hljs-keyword">private</span> String address;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String name, String address, <span class="hljs-keyword">int</span> number)</span></span><span class="hljs-function">   </span>&#123;      System.out.println(<span class="hljs-string">&quot;Constructing an Employee&quot;</span>);      <span class="hljs-keyword">this</span>.name = name;      <span class="hljs-keyword">this</span>.address = address;      <span class="hljs-keyword">this</span>.number = number;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">computePay</span><span class="hljs-params">()</span></span><span class="hljs-function">   </span>&#123;     System.out.println(<span class="hljs-string">&quot;Inside Employee computePay&quot;</span>);     <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mailCheck</span><span class="hljs-params">()</span></span><span class="hljs-function">   </span>&#123;      System.out.println(<span class="hljs-string">&quot;Mailing a check to &quot;</span> + <span class="hljs-keyword">this</span>.name       + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-keyword">this</span>.address);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span><span class="hljs-function">   </span>&#123;      <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot; &quot;</span> + address + <span class="hljs-string">&quot; &quot;</span> + number;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><span class="hljs-function">   </span>&#123;      <span class="hljs-keyword">return</span> name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span></span><span class="hljs-function">   </span>&#123;      <span class="hljs-keyword">return</span> address;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String newAddress)</span></span><span class="hljs-function">   </span>&#123;      address = newAddress;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumber</span><span class="hljs-params">()</span></span><span class="hljs-function">   </span>&#123;     <span class="hljs-keyword">return</span> number;   &#125;&#125;</code></pre></div><p>注意到该 Employee 类没有什么不同，尽管该类是抽象类，但是它仍然有 3 个成员变量，7 个成员方法和 1 个构造方法。 现在如果你尝试如下的例子：</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">/* 文件名 : AbstractDemo.java */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractDemo</span></span><span class="hljs-class"></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span></span><span class="hljs-function">   </span>&#123;      <span class="hljs-comment">/* 以下是不允许的，会引发错误 */</span>      Employee e = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;George W.&quot;</span>, <span class="hljs-string">&quot;Houston, TX&quot;</span>, <span class="hljs-number">43</span>);       System.out.println(<span class="hljs-string">&quot;\n Call mailCheck using Employee reference--&quot;</span>);      e.mailCheck();    &#125;&#125;</code></pre></div><p>当你尝试编译AbstractDemo类时，会产生如下错误：</p><div class="hljs code-wrapper"><pre><code class="hljs pony"><span class="hljs-type">Employee</span>.java:<span class="hljs-number">46</span>: <span class="hljs-type">Employee</span> <span class="hljs-keyword">is</span> abstract; cannot <span class="hljs-keyword">be</span> instantiated      <span class="hljs-type">Employee</span> e = <span class="hljs-keyword">new</span> <span class="hljs-type">Employee</span>(<span class="hljs-string">&quot;George W.&quot;</span>, <span class="hljs-string">&quot;Houston, TX&quot;</span>, <span class="hljs-number">43</span>);                   ^<span class="hljs-number">1</span> <span class="hljs-keyword">error</span></code></pre></div><h2 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h2><p>我们能通过一般的方法继承Employee类：</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">/* 文件名 : Salary.java */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Salary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary; <span class="hljs-comment">//Annual salary</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Salary</span><span class="hljs-params">(String name, String address, <span class="hljs-keyword">int</span> number, <span class="hljs-keyword">double</span></span></span><span class="hljs-function"><span class="hljs-params">      salary)</span></span><span class="hljs-function">   </span>&#123;       <span class="hljs-keyword">super</span>(name, address, number);       setSalary(salary);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mailCheck</span><span class="hljs-params">()</span></span><span class="hljs-function">   </span>&#123;       System.out.println(<span class="hljs-string">&quot;Within mailCheck of Salary class &quot;</span>);       System.out.println(<span class="hljs-string">&quot;Mailing check to &quot;</span> + getName()       + <span class="hljs-string">&quot; with salary &quot;</span> + salary);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span></span><span class="hljs-function">   </span>&#123;       <span class="hljs-keyword">return</span> salary;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSalary</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newSalary)</span></span><span class="hljs-function">   </span>&#123;       <span class="hljs-keyword">if</span>(newSalary &gt;= <span class="hljs-number">0.0</span>)       &#123;          salary = newSalary;       &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">computePay</span><span class="hljs-params">()</span></span><span class="hljs-function">   </span>&#123;      System.out.println(<span class="hljs-string">&quot;Computing salary pay for &quot;</span> + getName());      <span class="hljs-keyword">return</span> salary/<span class="hljs-number">52</span>;   &#125;&#125;</code></pre></div><p>尽管我们不能实例化一个 Employee 类的对象，但是如果我们实例化一个 Salary 类对象，该对象将从 Employee 类继承 7 个成员方法，且通过该方法可以设置或获取三个成员变量。</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">/* 文件名 : AbstractDemo.java */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractDemo</span></span><span class="hljs-class"></span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span></span><span class="hljs-function">   </span>&#123;      Salary s = <span class="hljs-keyword">new</span> Salary(<span class="hljs-string">&quot;Mohd Mohtashim&quot;</span>, <span class="hljs-string">&quot;Ambehta, UP&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3600.00</span>);      Employee e = <span class="hljs-keyword">new</span> Salary(<span class="hljs-string">&quot;John Adams&quot;</span>, <span class="hljs-string">&quot;Boston, MA&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2400.00</span>);       System.out.println(<span class="hljs-string">&quot;Call mailCheck using Salary reference --&quot;</span>);      s.mailCheck();       System.out.println(<span class="hljs-string">&quot;\n Call mailCheck using Employee reference--&quot;</span>);      e.mailCheck();    &#125;&#125;</code></pre></div><p>以上程序编译运行结果如下：</p><div class="hljs code-wrapper"><pre><code class="hljs smali">Constructing an EmployeeConstructing an EmployeeCall mailCheck using  Salary reference --Within mailCheck of Salary classMailing<span class="hljs-built_in"> check </span>to Mohd Mohtashim with salary 3600.0Call mailCheck using Employee reference--Within mailCheck of Salary classMailing<span class="hljs-built_in"> check </span>to John Adams with salary 2400.</code></pre></div><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。<br>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。<br>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>&#123;   <span class="hljs-keyword">private</span> String name;   <span class="hljs-keyword">private</span> String address;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">computePay</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">//其余代码</span>&#125;</code></pre></div><p>声明抽象方法会造成以下两个结果：</p><ul><li>如果一个类包含抽象方法，那么该类必须是抽象类。</li><li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。<br>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。<br>如果Salary类继承了Employee类，那么它必须实现computePay()方法：<div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">/* 文件名 : Salary.java */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Salary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary; <span class="hljs-comment">// Annual salary</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">computePay</span><span class="hljs-params">()</span></span><span class="hljs-function">   </span>&#123;      System.out.println(<span class="hljs-string">&quot;Computing salary pay for &quot;</span> + getName());      <span class="hljs-keyword">return</span> salary/<span class="hljs-number">52</span>;   &#125;    <span class="hljs-comment">//其余代码</span>&#125;</code></pre></div></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p></li><li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p></li><li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p></li><li><p>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p></li><li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】instanceof</title>
    <link href="/2020/08/27/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Ainstanceof/"/>
    <url>/2020/08/27/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Ainstanceof/</url>
    
    <content type="html"><![CDATA[<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>因为Java是一个面向对象的语言，需要通过创建实例来实现算法，所以Java中有一个instanceof操作符，用来判断实例是否属于某一个类。</p><p>instanceof是一个二元操作符，类似于 ==，&gt;，&lt; 等操作符，返回boolean数据类型。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><div class="hljs code-wrapper"><pre><code class="hljs coffeescript">result = object <span class="hljs-keyword">instanceof</span> <span class="hljs-class"><span class="hljs-keyword">class</span>;</span></code></pre></div><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>Result：布尔类型。<br>Object：必选项。任意对象表达式。<br>Class：必选项。任意已定义的对象类。</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】二叉树</title>
    <link href="/2020/08/26/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/08/26/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="编写二叉树"><a href="#编写二叉树" class="headerlink" title="编写二叉树"></a>编写二叉树</h2><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;    <span class="hljs-keyword">int</span> val;    TreeNode left;    TreeNode right;    TreeNode(<span class="hljs-keyword">int</span> x) &#123; val = x; &#125; &#125;</code></pre></div><h2 id="题目编号"><a href="#题目编号" class="headerlink" title="题目编号"></a>题目编号</h2><p>226 101</p><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>二叉树分为左右节点，首先考虑一个节点，将左右子节点交换，然后递归到左右子节点。结束条件是节点为null</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-comment">// 递归</span>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 创建交换的中间媒介</span>        TreeNode tmp = root.right;        <span class="hljs-comment">// 左右子树交换</span>        root.right = root.left;        root.left = tmp;        <span class="hljs-comment">// 继续递归</span>        invertTree(root.right);        invertTree(root.left);        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre></div><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>一开始我理解错了，以为就是一个判断根节点的左右子节点是否相等的问题。所以一开始的代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">while</span>(root != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span>(root.left != root.right)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                isSymmetric(root.left);                isSymmetric(root.right);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><p>结果带入测试用例答案不对，才发现此题是判断右子节点的右节点和左子节点的左节点还有右子节点的左节点和左子节点的右节点是否相等。<br>这是一个典型递归问题,因为涉及到左子树的子节点和右子树的子节点，所以要另立一个函数isSub(TreeNode L, TreeNode R)来解决。<br>如果左右都为空，则返回true。如果只有其中一个为空或者两个值不相等，则返回false。其他情况则继续向下探索。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 根节点为空则返回true</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> isSub(root.left, root.right); <span class="hljs-comment">// 不为空则探索子节点</span>        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSub</span><span class="hljs-params">(TreeNode L, TreeNode R)</span></span>&#123;        <span class="hljs-keyword">if</span>(L == <span class="hljs-keyword">null</span> &amp;&amp; R == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 如果左右都为空，则返回true</span>        <span class="hljs-keyword">if</span>(L == <span class="hljs-keyword">null</span> || R == <span class="hljs-keyword">null</span> || L.val != R.val)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 如果只有其中一个为空或者两个值不相等，则返回false</span>        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> isSub(L.left, R.right) &amp;&amp; isSub(L.right, R.left); <span class="hljs-comment">// 其他情况则继续向下探索</span>        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈遗传算法：用遗传算法求最大值</title>
    <link href="/2020/08/20/%E8%B0%88%E8%B0%88%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
    <url>/2020/08/20/%E8%B0%88%E8%B0%88%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="遗传算法简介"><a href="#遗传算法简介" class="headerlink" title="遗传算法简介"></a>遗传算法简介</h1><p>遗传算法运用自然界优胜劣汰的法则，可以解决大多数最优解问题，算法过程如下：</p><ol><li>将要解决的问题主体进行编码，形成初始种群。</li><li>用选择函数对种群中的个体进行选择。</li><li>将生存的个体进行交叉，生成子代。</li><li>交叉中设置一定的变异率，防止陷入局部最优解。</li><li>将2.3.4.循环操作最终的到最优种群集合，在其中找到最优解</li></ol><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><blockquote><p>求解函数 2 * math.sin( 2 * x ) + math.cos( 3 * x )在区间[0,9]的最大值。(保留)</p></blockquote><h1 id="遗传算法解决策"><a href="#遗传算法解决策" class="headerlink" title="遗传算法解决策"></a>遗传算法解决策</h1><p>假定需要保留四位小数，那么就一共有90000个可能性，那么</p><center>2^16 < 90000 < 2^17 </center><p><strong>可以将所有可能性都包含在内，下面将其进行二进制的转换</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_chromosome</span>(<span class="hljs-params">self, length</span>):</span><span class="hljs-comment"># 随机生成染色体变量</span>    <span class="hljs-comment"># a bit ( 0, 1 ) represent a gene</span>    chromosome = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i  <span class="hljs-keyword">in</span> range(length):chromosome |= ( <span class="hljs-number">1</span> &lt;&lt; i ) * random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)   <span class="hljs-keyword">return</span> chromosome</code></pre></div><p><strong>将字符二进制编码后还需进行解码，解码我们用</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode</span>(<span class="hljs-params">self, chromosome</span>):</span><span class="hljs-comment"># 将二进制还原成十进制</span>    <span class="hljs-keyword">return</span> chromosome * <span class="hljs-number">9.0</span>/ (<span class="hljs-number">2</span>**(self.length)<span class="hljs-number">-1</span>)</code></pre></div><p><strong>将得到的种群进行选择，我们要用到题目中所给的选择条件</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fitness</span>(<span class="hljs-params">self, chromosome</span>):</span><span class="hljs-comment"># 解码和适应性函数</span>    x = self.decode(chromosome)    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * math.sin( <span class="hljs-number">2</span> * x ) + math.cos( <span class="hljs-number">3</span> * x )</code></pre></div><p><strong>然后进行编写选择模块</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selection</span>(<span class="hljs-params">self, retain_rate, random_select_rate</span>):</span><span class="hljs-comment"># 通过适应度大小从大到小进行排序，最后生成的仍然是二进制的列表</span>    graded = [(self.fitness(chromosome), chromosome) <span class="hljs-keyword">for</span> chromosome <span class="hljs-keyword">in</span> self.population]    graded = [x[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> sorted(graded, reverse=<span class="hljs-literal">True</span>)]    <span class="hljs-comment"># 选出适应性强的染色体,挑选20%作为父类</span>    retain_length = int(len(graded) * retain_rate)    parents = graded[:retain_length]    <span class="hljs-comment"># 从剩余的80%里面选出适应性不强，但是幸存的染色体（概率0.5）</span>    <span class="hljs-keyword">for</span> chromosome <span class="hljs-keyword">in</span> graded[retain_length:]:    <span class="hljs-keyword">if</span> random.random() &lt; random_select_rate:            parents.append(chromosome)    <span class="hljs-keyword">return</span> parents</code></pre></div><p><strong>编写交叉模块</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crossover</span>(<span class="hljs-params">self, parents</span>):</span>    <span class="hljs-comment"># 交叉产生后代</span>    <span class="hljs-comment"># 新出生的孩子，最终会被加入存活下来的父母之中，形成新一代的种群。</span>    children = []    <span class="hljs-comment"># 需要繁殖的数量</span>    target_count = len(self.population) - len(parents)    <span class="hljs-keyword">while</span> len(children) &lt; target_count:        malelocation = random.randint(<span class="hljs-number">0</span>, len(parents) - <span class="hljs-number">1</span>)        femalelocation = random.randint(<span class="hljs-number">0</span>, len(parents) - <span class="hljs-number">1</span>)        male = parents[malelocation]        female = parents[femalelocation]        <span class="hljs-keyword">if</span> malelocation != femalelocation:            <span class="hljs-comment"># 随机选择交叉点</span>            cross_pos = random.randint(<span class="hljs-number">0</span>, self.length)            <span class="hljs-comment"># 生成掩码，方便位运算</span>            mask = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(cross_pos):                mask |= (<span class="hljs-number">1</span> &lt;&lt; i )            <span class="hljs-comment"># 孩子将获得父亲在交叉点前的基因和母亲在交叉点后（包括交叉点）的基因</span>            child = (male &amp; mask) | (female &amp; ~mask)            children.append(child)    <span class="hljs-comment"># 经过繁殖后，孩子和父母的数量与原始种群数量相等，在这里可以更新种群。</span>    self.population = parents + children</code></pre></div><p><strong>编写变异模块</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mutation</span>(<span class="hljs-params">self, rate</span>):</span>    <span class="hljs-comment"># 对种群中的所有个体，随机改变某个个体中的某个基因</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(self.population)):        <span class="hljs-keyword">if</span> random.random() &lt; rate:            j = random.randint(<span class="hljs-number">0</span>, self.length - <span class="hljs-number">1</span>)            <span class="hljs-comment"># 随机取得一个数j对变异基因1进行随机移动</span>            self.population[i] = self.population[i] ^ ( <span class="hljs-number">1</span> &lt;&lt; j )  <span class="hljs-comment"># ^是异或运算</span></code></pre></div><p>遗传算法求最大值的总体思路就是这样，思想上还是相当简单的，下面我们把所有代码组合起来，加上框架，就可以做成一个完整的<strong>遗传算法求最大值</strong>的程序</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># !/usr/bin/env python</span><span class="hljs-comment"># -*- coding:utf-8 -*-</span><span class="hljs-comment"># 求解函数 2 * math.sin( 2 * x ) + math.cos( 3 * x )在区间[0,9]的最大值。</span><span class="hljs-keyword">import</span> math<span class="hljs-keyword">import</span> random<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GA</span>():</span>    <span class="hljs-comment"># initalise</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, length, count</span>):</span>        <span class="hljs-comment"># 染色体长度</span>        self.length = length        <span class="hljs-comment"># 染色体数量</span>        self.count = count        <span class="hljs-comment"># 形成原始种群</span>        self.population = self.get_population(length, count)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_population</span>(<span class="hljs-params">self, length, count</span>):</span>        <span class="hljs-comment"># get a list of count numbers chromosome (length : length)</span>        <span class="hljs-keyword">return</span> [self.get_chromosome(length) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(count)]        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_chromosome</span>(<span class="hljs-params">self, length</span>):</span>        <span class="hljs-comment"># 随机生成染色体变量</span>        <span class="hljs-comment"># a bit ( 0, 1 ) represent a gene</span>        chromosome = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i  <span class="hljs-keyword">in</span> range(length):            chromosome |= ( <span class="hljs-number">1</span> &lt;&lt; i ) * random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)        print(chromosome)        print(chromosome * <span class="hljs-number">9.0</span>/ (<span class="hljs-number">2</span>**(self.length)<span class="hljs-number">-1</span>))        <span class="hljs-keyword">return</span> chromosome        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evolve</span>(<span class="hljs-params">self, retain_rate = <span class="hljs-number">0.2</span>, random_select_rate = <span class="hljs-number">0.5</span>, mutation_rate = <span class="hljs-number">0.01</span> </span>):</span>                parents = self.selection(retain_rate, random_select_rate)        self.crossover(parents)        self.mutation(mutation_rate)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fitness</span>(<span class="hljs-params">self, chromosome</span>):</span>        <span class="hljs-comment"># 解码和适应性函数</span>        x = self.decode(chromosome)        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * math.sin( <span class="hljs-number">2</span> * x ) + math.cos( <span class="hljs-number">3</span> * x )        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selection</span>(<span class="hljs-params">self, retain_rate, random_select_rate</span>):</span>        <span class="hljs-comment"># 通过适应度大小从大到小进行排序，最后生成的仍然是二进制的列表</span>        graded = [(self.fitness(chromosome), chromosome) <span class="hljs-keyword">for</span> chromosome <span class="hljs-keyword">in</span> self.population]        graded = [x[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> sorted(graded, reverse=<span class="hljs-literal">True</span>)]                <span class="hljs-comment"># 选出适应性强的染色体,挑选20%作为父类</span>        retain_length = int(len(graded) * retain_rate)        parents = graded[:retain_length]                <span class="hljs-comment"># 从剩余的80%里面选出适应性不强，但是幸存的染色体（概率0.5）</span>        <span class="hljs-keyword">for</span> chromosome <span class="hljs-keyword">in</span> graded[retain_length:]:            <span class="hljs-keyword">if</span> random.random() &lt; random_select_rate:                parents.append(chromosome)        <span class="hljs-keyword">return</span> parents        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crossover</span>(<span class="hljs-params">self, parents</span>):</span>        <span class="hljs-comment"># 交叉产生后代</span>        <span class="hljs-comment"># 新出生的孩子，最终会被加入存活下来的父母之中，形成新一代的种群。</span>        children = []        <span class="hljs-comment"># 需要繁殖的数量</span>        target_count = len(self.population) - len(parents)        <span class="hljs-keyword">while</span> len(children) &lt; target_count:            malelocation = random.randint(<span class="hljs-number">0</span>, len(parents) - <span class="hljs-number">1</span>)            femalelocation = random.randint(<span class="hljs-number">0</span>, len(parents) - <span class="hljs-number">1</span>)            male = parents[malelocation]            female = parents[femalelocation]            <span class="hljs-keyword">if</span> malelocation != femalelocation:                <span class="hljs-comment"># 随机选择交叉点</span>                cross_pos = random.randint(<span class="hljs-number">0</span>, self.length)                <span class="hljs-comment"># 生成掩码，方便位运算</span>                mask = <span class="hljs-number">0</span>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(cross_pos):                    mask |= (<span class="hljs-number">1</span> &lt;&lt; i )                <span class="hljs-comment"># 孩子将获得父亲在交叉点前的基因和母亲在交叉点后（包括交叉点）的基因</span>                child = (male &amp; mask) | (female &amp; ~mask)                children.append(child)        <span class="hljs-comment"># 经过繁殖后，孩子和父母的数量与原始种群数量相等，在这里可以更新种群。</span>        self.population = parents + children        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mutation</span>(<span class="hljs-params">self, rate</span>):</span>        <span class="hljs-comment"># 对种群中的所有个体，随机改变某个个体中的某个基因</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(self.population)):            <span class="hljs-keyword">if</span> random.random() &lt; rate:                j = random.randint(<span class="hljs-number">0</span>, self.length - <span class="hljs-number">1</span>)                <span class="hljs-comment"># 随机取得一个数j对变异基因1进行随机移动</span>                self.population[i] = self.population[i] ^ ( <span class="hljs-number">1</span> &lt;&lt; j )  <span class="hljs-comment"># ^是异或运算</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode</span>(<span class="hljs-params">self, chromosome</span>):</span>        <span class="hljs-comment"># 将二进制还原成十进制</span>        <span class="hljs-keyword">return</span> chromosome * <span class="hljs-number">9.0</span>/ (<span class="hljs-number">2</span>**(self.length)<span class="hljs-number">-1</span>)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">result</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-comment"># 获得当前最优的个体值</span>        graded = [(self.fitness(chromosome), chromosome) <span class="hljs-keyword">for</span> chromosome <span class="hljs-keyword">in</span> self.population]        graded = [ x[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> sorted(graded, reverse = <span class="hljs-literal">True</span>)]        X1 = [i / float(<span class="hljs-number">10</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1</span>)]        Y1 = [<span class="hljs-number">2</span> * math.sin( <span class="hljs-number">2</span> * x ) + math.cos( <span class="hljs-number">3</span> * x ) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> X1]        plt.plot(X1, Y1)        plt.show()        <span class="hljs-keyword">return</span> ga.decode(graded[<span class="hljs-number">0</span>])<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    <span class="hljs-comment"># 染色体长度为17，群落数量是300</span>    ga = GA(<span class="hljs-number">17</span>, <span class="hljs-number">300</span>)    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">200</span>):        ga.evolve()    print(<span class="hljs-string">&#x27;x = %f&#x27;</span> %(ga.result()))</code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>遗传算法在思想上还是很简单的存在，并且可以通过变异避免陷入局部最优解，但是缺点也很明显，因为要通过不停迭代不停选择，所以运行时间比较长，而且种群数量变大的话，对于电脑的资源消耗也变高。  </p></li><li><p>遗传算法的难点在于对于现实中的物体进行编码，并且染色体交叉后是否会出现不合规的染色体，比如在用遗传算法解决pick up and delivery问题上，配送的先后顺序也要考虑到，这些都是今后需要考虑的点。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>谈谈技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>算法</tag>
      
      <tag>遗传算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】50. 第一个只出现一次的字符</title>
    <link href="/2020/08/19/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A50/"/>
    <url>/2020/08/19/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A50/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a>剑指 Offer 50. 第一个只出现一次的字符</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">s</span> = <span class="hljs-string">&quot;abaccdeff&quot;</span>返回 <span class="hljs-string">&quot;b&quot;</span><span class="hljs-attribute">s</span> = <span class="hljs-string">&quot;&quot;</span> 返回 <span class="hljs-string">&quot; &quot;</span></code></pre></div><h2 id="解题思路1"><a href="#解题思路1" class="headerlink" title="解题思路1"></a>解题思路1</h2><p>跟<a href="https://liuminxuan.github.io/2020/08/18/Leetcodes%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/">leetcode387</a>差不多，只是返回值不一样，稍加修改就可以提交了。<br>用数组自创哈希表，因为只有小写字母，所以设置一个26长度的数组，字符串中出现一次，数组里对应的字母就+1，然后再对字符串的字母一一对照，如果值为1就输出，找不到1则无解。</p><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;       <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 因为都是小写字母，所以数组取26</span>        <span class="hljs-keyword">char</span>[] chars = s.toCharArray();         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : chars)&#123;            count[c-<span class="hljs-string">&#x27;a&#x27;</span>]++; <span class="hljs-comment">// 因为是ASCII码字母出现一次+1</span>        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;            <span class="hljs-keyword">if</span>(count[s.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">1</span>)&#123;                <span class="hljs-keyword">return</span> s.charAt(i); <span class="hljs-comment">// 找出只出现一次的字母</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>; <span class="hljs-comment">// 无解</span>    &#125;&#125;</code></pre></div><h2 id="解题思路2"><a href="#解题思路2" class="headerlink" title="解题思路2"></a>解题思路2</h2><p>除去用数组做，第一印象肯定是HashMap，但是其结果却不尽人意。<br>究其原因，HashMap是由一个链表组成，其查找速度必然不如O(1)的数组，但是在插入和删除操作的时候，其查找速度比数组快。</p><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-comment">// 数组为空，返回空</span>        <span class="hljs-keyword">if</span>(s.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;        HashMap&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27; &#x27;</span>;        <span class="hljs-comment">// 遍历字符串，分别放入HashMap，第一次放入则值为0</span>        <span class="hljs-comment">// 而后出现相同的时候取出Key对应的value，然后将value+1，放回Key对应的value中</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.length(); i++)&#123;            c = s.charAt(i);            <span class="hljs-keyword">if</span>(!map.containsKey(c))&#123;                map.put(c, <span class="hljs-number">0</span>);            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-comment">// map.put(c, 1);</span>                <span class="hljs-keyword">int</span> v = map.get(c);                <span class="hljs-comment">// map.remove(c);</span>                v++;                map.put(c, v);            &#125;        &#125;        <span class="hljs-comment">// </span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.length(); i++)&#123;            c = s.charAt(i);            <span class="hljs-keyword">if</span> (map.get(c) == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> c;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>剑指offer刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】字符串</title>
    <link href="/2020/08/18/Leetcodes%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2020/08/18/Leetcodes%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目编号"><a href="#题目编号" class="headerlink" title="题目编号"></a>题目编号</h2><p>38 387</p><h2 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38.外观数列"></a>38.外观数列</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为后一项是前一项决定的，所以用循环来做。<br>选取第一个数，然后数后面有多少相同，最后用appned加上去。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        String str = <span class="hljs-string">&quot;1&quot;</span>; <span class="hljs-comment">// 第一个数</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();            <span class="hljs-keyword">char</span> pre = str.charAt(<span class="hljs-number">0</span>); <span class="hljs-comment">// 取出头部的数字</span>            <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; str.length(); j++) &#123;                <span class="hljs-comment">// 如果后面的数与第一个相同，则count++</span>                <span class="hljs-comment">// 否则用append方法将头部数字的个数和头部数字加入字符串中</span>                <span class="hljs-keyword">if</span>(pre == str.charAt(j))&#123;                    count++;                &#125;<span class="hljs-keyword">else</span>&#123;                    sb.append(count).append(pre);                    pre = str.charAt(j); <span class="hljs-comment">// 选取下一个头部数字</span>                    count = <span class="hljs-number">1</span>; <span class="hljs-comment">// count归1</span>                &#125;            &#125;            <span class="hljs-comment">// 最后跳出循环时未处理最后一个头部数字，在此在此处理</span>            sb.append(count).append(pre);            str = sb.toString();        &#125;        <span class="hljs-keyword">return</span> str;    &#125;&#125;</code></pre></div><h2 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>用数组自创哈希表，因为只有小写字母，所以设置一个26长度的数组，字符串中出现一次，数组里对应的字母就+1，然后再对字符串的字母一一对照，如果值为1就输出，找不到1则无解。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> count[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;            count[s.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>]++;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;            <span class="hljs-keyword">if</span>(count[s.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">1</span>)&#123;                <span class="hljs-keyword">return</span> i;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】36. 有效的数独</title>
    <link href="/2020/08/17/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/"/>
    <url>/2020/08/17/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36.有效的数独"></a>36.有效的数独</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>第一想到的是哈希表，所以给每一行每一列每个九宫格设置一个哈希表，出现数字则标记，如果查询到被标记过的数字，则数独不成立。<br>每行每列比较简单，设置一个9*10的数组就可以解决，9是数独的行和列，10是数独里面所填的值。比较数独里九宫格里的数就比较复杂，我们可以利用int做除法只能取整的特性求解。<br>比如第一第二个九宫格<br>(0,0) -&gt; 0<br>(0,1) -&gt; 0<br>(0,2) -&gt; 0<br>(1,0) -&gt; 0<br>(1,1) -&gt; 0<br>(1,2) -&gt; 0<br>(2,0) -&gt; 0<br>(2,1) -&gt; 0<br>(2,2) -&gt; 0</p><p>(0,3) -&gt; 3<br>(0,4) -&gt; 3<br>(0,5) -&gt; 3<br>(1,3) -&gt; 3<br>(1,4) -&gt; 3<br>(1,5) -&gt; 3<br>(2,3) -&gt; 3<br>(2,4) -&gt; 3<br>(2,5) -&gt; 3</p><p>可以看出九个九宫格可以填入9*10的哈希表</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-keyword">int</span>[][] row = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>]; <span class="hljs-comment">// 记录行</span>        <span class="hljs-keyword">int</span>[][] col = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>]; <span class="hljs-comment">// 记录列</span>        <span class="hljs-keyword">int</span>[][] box = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">9</span>][<span class="hljs-number">10</span>]; <span class="hljs-comment">// 记录九宫格</span>        init(row);        init(col);        init(box);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">int</span> compare = board[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>;                <span class="hljs-keyword">if</span> (row[i][compare] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">if</span> (col[j][compare] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">if</span>(box[i/<span class="hljs-number">3</span>+(j/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][compare] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">//利用int特性分离九宫格</span>                row[i][compare]++; <span class="hljs-comment">// 标记查询过的行</span>                col[j][compare]++; <span class="hljs-comment">// 标记查询过的列</span>                box[i/<span class="hljs-number">3</span>+(j/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>][compare]++;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">// 初始化</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] init(<span class="hljs-keyword">int</span>[][] matrix) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;                matrix[i][j] = <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> matrix;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】滑动窗口</title>
    <link href="/2020/05/03/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2020/05/03/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="题目编号"><a href="#题目编号" class="headerlink" title="题目编号"></a>题目编号</h2><p>3 209</p><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>一开始以子串的长度为基准，发现循环中的代码非常复杂，一不注意就出错，后来看了评论才知道应该以左边的数字为基准，外层循环遍历整个字符串，内层循环遍历当前子串是否有相同的字符。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">int</span> maxCount = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>; <span class="hljs-comment">// 左边的那个数</span>        <span class="hljs-keyword">char</span>[] sToChar = s.toCharArray();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> in = left; in &lt; i; in++) &#123;                <span class="hljs-keyword">if</span> (sToChar[in] == sToChar[i]) &#123;                    maxCount = Math.max(maxCount, i - left);                    left = in + <span class="hljs-number">1</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        maxCount = Math.max(maxCount, sToChar.length - left);        <span class="hljs-keyword">return</span> maxCount;    &#125;&#125;</code></pre></div><a id="more"></a><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>暴力破解法：</p><ul><li>从第一个数开始往后加，加到满足条件看有几个元素，</li><li>从第二个数开始往后加，加到满足条件看有几个元素，然后跟第一个比较，</li><li>从第三个数开始往后加，加到满足条件看有几个元素，然后跟第二个比较，</li><li>。。。得出结果</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">int</span> right = i;            <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (; right &lt; nums.length; right++) &#123;                sum += nums[right];                <span class="hljs-keyword">if</span> (sum &gt;= s) &#123;                    <span class="hljs-comment">// 这里因为i已经加了1，但是right还没加1，所以得把1补过来</span>                    len = Math.min(len, right - i + <span class="hljs-number">1</span>);                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> len == nums.length + <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : len;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】67. 二进制求和</title>
    <link href="/2020/05/03/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E2%80%9C/"/>
    <url>/2020/05/03/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E2%80%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目编号"><a href="#题目编号" class="headerlink" title="题目编号"></a>题目编号</h2><p>67</p><h2 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a>67. 二进制求和</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>之前在Java学习笔记中写到过<a href="https://liuminxuan.github.io/2020/01/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BD%8D%E8%BF%90%E7%AE%97/">位运算</a>，这次在Leetcode中也遇到了，二进制只有1和0，所以将位运算加入其中，计算完一位后就将进位数移位，进行下一轮计算。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addBinary</span><span class="hljs-params">(String a, String b)</span> </span>&#123;      <span class="hljs-keyword">if</span>(a == <span class="hljs-keyword">null</span> || a.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> b; <span class="hljs-comment">// </span>        <span class="hljs-keyword">if</span>(b == <span class="hljs-keyword">null</span> || b.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;        StringBuilder stb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">int</span> i = a.length() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> j = b.length() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 进位</span>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span>) c += a.charAt(i --) - <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">// 进位数与a相加</span>            <span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">0</span>) c += b.charAt(j --) - <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">// 进位数与b相加</span>            stb.append(c % <span class="hljs-number">2</span>);            c &gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 移位运算</span>        &#125;        String res = stb.reverse().toString(); <span class="hljs-comment">// 字符串反转</span>        <span class="hljs-keyword">return</span> c &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;1&#x27;</span> + res : res; <span class="hljs-comment">//判断进位  </span>    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】贪心</title>
    <link href="/2020/04/30/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%B4%AA%E5%BF%83/"/>
    <url>/2020/04/30/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h2 id="题目编号"><a href="#题目编号" class="headerlink" title="题目编号"></a>题目编号</h2><p>53 121</p><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为负数加负数更小，所以当目前总和为负数时，跟下一个负数只取一个较大的负数。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dt = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];        dt[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> maxSum = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-comment">// 找出正数最多的子序列</span>            <span class="hljs-comment">// 负数相加只会越来越小，所以当总和小于零时遇上负数直接把前面舍弃</span>            dt[i] = Math.max(dt[i - <span class="hljs-number">1</span>],<span class="hljs-number">0</span>) + nums[i];            <span class="hljs-keyword">if</span> (dt[i] &gt; maxSum) &#123;                <span class="hljs-comment">//因为会遍历到底，所以要记录遍历途中最大的数</span>                maxSum = dt[i];            &#125;        &#125;        <span class="hljs-keyword">return</span> maxSum;    &#125;</code></pre></div><a id="more"></a><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为只买卖一次，所以只要找到最大值前面的最小值就行了，每次模拟买入卖出情况，找出最大差值，解决问题。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<span class="hljs-comment">// 输入为空时，返回0</span>        <span class="hljs-keyword">if</span> (prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> buy = prices[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> profit = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> maxProfit = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;            <span class="hljs-keyword">if</span> (prices[i] &lt; buy) &#123;                <span class="hljs-comment">// 模拟买入，如果买入价格比之前低，就买入备选</span>                buy = prices[i];            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prices[i] &gt; buy) &#123;                <span class="hljs-comment">// 每次模拟卖出的情况</span>                profit = prices[i] - buy;                <span class="hljs-keyword">if</span> (profit &gt; maxProfit) &#123;                    <span class="hljs-comment">// 如果利润大于最大利润，就卖出备选</span>                    maxProfit = profit;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> maxProfit;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】链表</title>
    <link href="/2020/04/26/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/04/26/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目编号"><a href="#题目编号" class="headerlink" title="题目编号"></a>题目编号</h1><p>206 141 21 19 876 160</p><h2 id="编写链表"><a href="#编写链表" class="headerlink" title="编写链表"></a>编写链表</h2><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;        <span class="hljs-keyword">int</span> val;        ListNode next;        ListNode(<span class="hljs-keyword">int</span> x) &#123;            val = x;        &#125;    &#125;</code></pre></div><a id="more"></a><h1 id="易犯错误"><a href="#易犯错误" class="headerlink" title="易犯错误"></a>易犯错误</h1><ul><li>最近遇到一个问题：</li></ul><hr><p> head   –&gt; val = 6 –&gt; val = 13 –&gt; val = 17 –&gt; val = 21</p><hr><p>求head.next.next.val = ?</p><ul><li>解题思路：<br>因为头指针head只指向头节点所在的地址，并不包含数据，所以不能把头指针看作一个节点，所以head.next.next.val = 17.</li></ul><h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>类似于选择排序中交换两个数的位置。借助一个tmp完成交换</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        ListNode pre = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 前元素</span>        ListNode cur = head; <span class="hljs-comment">// 正在操作的元素</span>        ListNode tmp = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 临时元素</span>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;            tmp = cur.next;             cur.next = pre;            pre = cur;            cur = tmp;        &#125;        <span class="hljs-keyword">return</span> pre;    &#125;</code></pre></div><h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为如果是环形链表，一定会陷入无限循环。所以用快慢指针解决。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        ListNode low = head;        ListNode fast = head.next;        <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span>(fast.equals(low))&#123;                <span class="hljs-comment">// 慢指针追上了快指针</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            low = low.next;            fast = fast.next.next;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;</code></pre></div><h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h1><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>创建一个新链表，比较l1、l2两个链表的大小，将小的放进新链表。最后将剩余的接在新链表后面。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);        ListNode curr = dummy;        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;                curr.next = l1;                curr = curr.next;                l1 = l1.next;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l1.val &gt;= l2.val) &#123;                curr.next = l2;                curr = curr.next;                l2 = l2.next;            &#125;        &#125;        <span class="hljs-keyword">if</span> (l1 != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 如果l1有剩余，将剩余元素接上去</span>            curr.next = l1;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 与l1同理</span>            curr.next = l2;        &#125;        <span class="hljs-comment">// 装逼写法</span>        <span class="hljs-comment">// cur.next = l1 == null ? l2 : l1;</span>        <span class="hljs-keyword">return</span> dummy.next;    &#125;</code></pre></div><h1 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h1><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>用快慢指针，中间相隔n个数，快指针到末尾时，慢指针指向的下一个元素就是要删除的节点。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        dummy.next = head;        ListNode low = dummy;        ListNode fast = dummy;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            fast = fast.next;        &#125;        <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span>) &#123;            fast = fast.next;            low = low.next;        &#125;        <span class="hljs-keyword">if</span> (low.next.next == <span class="hljs-keyword">null</span>) &#123;            low.next = <span class="hljs-keyword">null</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            low.next = low.next.next;        &#125;        <span class="hljs-keyword">return</span> dummy.next;    &#125;</code></pre></div><h1 id="876-链表的中间节点"><a href="#876-链表的中间节点" class="headerlink" title="876. 链表的中间节点"></a>876. 链表的中间节点</h1><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>先遍历链表数出有多少个元素，第（k/2+1）个元素就是中间元素。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode head)</span> </span>&#123;       ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);       dummy.next = head;       ListNode low = dummy;       ListNode fast = dummy;       <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;       <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span>) &#123;           fast = fast.next;           k++;       &#125;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; i++) &#123;           low = low.next;       &#125;       <span class="hljs-keyword">return</span> low.next;   &#125;</code></pre></div><h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h1><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://pic.leetcode-cn.com/e0efdd908a8941e3c53a68a6049d88c437b8299e48540a772ab091b86695d981-image.png" alt="avatar"></p><p>首先初始化pA，pB开始遍历。当pA到尾巴的时候，回到pB开始遍历。pB同理。<br>这样pA的路线a+c+b，pB的路线b+c+a，可知他们如果有交点，一定在遍历的尾巴处。</p><p>如果两个链表没有相交，那么就变成了pA为a+b，pB为b+a，最终他们一定会遍历到null，所以返回其中一个即可。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;        ListNode pA = headA;        ListNode pB = headB;        <span class="hljs-keyword">while</span>(pA != pB)&#123;            pA = pA == <span class="hljs-keyword">null</span> ? headB : pA.next;            pB = pB == <span class="hljs-keyword">null</span> ? headA : pB.next;        &#125;        <span class="hljs-keyword">return</span> pA;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】访问限制修饰符</title>
    <link href="/2020/04/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2020/04/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="public"><a href="#public" class="headerlink" title="public"></a>public</h1><p>范围最广，可以访问任何一个在CLASSPATH下的类，接口，异常等。它往往对于对外的情况，也就是对象或类对外的一种接口的形式。</p><h1 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h1><p>对本包可见，同时也是为继承设计的访问修饰符，即使子类在包外也可访问父类的protect变量或方法。</p><h1 id="defult"><a href="#defult" class="headerlink" title="defult"></a>defult</h1><p>可以供类内部和本包中使用，任何处于本包下的类，接口，异常等，都可以互相访问，即使是父类没有用protected修饰的成员也可以。</p><h1 id="private"><a href="#private" class="headerlink" title="private"></a>private</h1><p>限制最严格的访问修饰符，仅供类内部访问。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>类内部</th><th>本包</th><th>子类</th><th>外部包</th></tr></thead><tbody><tr><td>private</td><td></td><td></td><td></td></tr><tr><td>default</td><td>default</td><td></td><td></td></tr><tr><td>protect</td><td>protect</td><td>protect</td><td>protect</td></tr><tr><td>public</td><td>public</td><td>public</td><td>public</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】构造方法</title>
    <link href="/2020/04/07/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <url>/2020/04/07/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>构造方法是类里的一个特殊的方法，他不能有返回值（包括void）。所谓构造方法，就是这个类在被实例化时（创建对象时）就要执行的方法，方法名为类的名字，一般的目的是为了给类进行一些初始化值。</p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MerchandiseV2WithConstructor</span><span class="hljs-params">(String name, String id, <span class="hljs-keyword">int</span> count,</span></span><span class="hljs-function"><span class="hljs-params">                                        <span class="hljs-keyword">double</span> soldPrice, <span class="hljs-keyword">double</span> purchasePrice)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.count = count;        <span class="hljs-keyword">this</span>.soldPrice = soldPrice;        <span class="hljs-keyword">this</span>.purchasePrice = purchasePrice;    &#125;</code></pre></div><h1 id="构造方法的继承"><a href="#构造方法的继承" class="headerlink" title="构造方法的继承"></a>构造方法的继承</h1><p>子类创建构造方法中一定会创建一个父类的构造方法，所以this和super不可以共存。</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】面向对象三要素</title>
    <link href="/2020/04/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E8%A6%81%E7%B4%A0/"/>
    <url>/2020/04/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E8%A6%81%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h1><p>用访问限制符(private)保护成员变量，用public将方法写在类里，在主函数中调用类中的方法，为封装。</p><h1 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h1><p>子类继承父类的成员变量和方法，并且可以在此基础上扩展出自己的成员变量和方法。父类中的private子类不可访问。</p><h1 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h1><p>子类可以用相同的方法名去覆盖父类的方法，同一种方法用覆盖(override)实现不同的结果就是多态。继承关系是必须的。</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】方法的重载和覆盖及参数的匹配规则</title>
    <link href="/2020/04/03/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E5%8F%8A%E5%8F%82%E6%95%B0%E7%9A%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
    <url>/2020/04/03/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E5%8F%8A%E5%8F%82%E6%95%B0%E7%9A%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="重载-overload"><a href="#重载-overload" class="headerlink" title="重载 overload"></a>重载 overload</h1><p>同一个类中如果有两个方法的方法名相同，但参数不一致，那么可以说一个方法是另一个方法的重载(overload)。</p><h1 id="覆盖-override"><a href="#覆盖-override" class="headerlink" title="覆盖 override"></a>覆盖 override</h1><p>继承中如果子类出现与父类相同的方法名与参数，则子类方法可以覆盖(overload)父类方法。调用的方法是对象所存在的那个引用中的方法</p><h1 id="重载的参数匹配规则"><a href="#重载的参数匹配规则" class="headerlink" title="重载的参数匹配规则"></a>重载的参数匹配规则</h1><p>依次使用byte, short, int, long, float, double 类型的参数调用方法。实参可以自动类型转换成高精度的形参，但是高精度不能转换成低精度。</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】堆和栈</title>
    <link href="/2020/03/26/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A0%86%E5%92%8C%E6%A0%88/"/>
    <url>/2020/03/26/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A0%86%E5%92%8C%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<ol><li>一些基本类型的变量和对象的引用变量都是在方法的栈(stack)中分配。</li><li>堆(heap)用于存放由new创建的对象和数组。</li></ol><ul><li>Java基本数据类型：共有8种，即int, short, long, byte, float, double, boolean, char。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】数组</title>
    <link href="/2020/01/21/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E7%BB%84/"/>
    <url>/2020/01/21/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>以前学数组，总是学的稀里糊涂，对数组的生成以及对数组内存储数的查找并不明白是怎么一回事。</p><p>最近温习Java的数组操作，对数组也有了一点更深的认识。</p><p>先来看一段程序:</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WhatIsArray</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;                <span class="hljs-keyword">int</span>[] book = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];        book[<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>;        System.out.println(book[<span class="hljs-number">0</span>]);        book = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];        System.out.println(book[<span class="hljs-number">0</span>]);    &#125;&#125;</code></pre></div><a id="more"></a><p>计算机生成数组的过程如下：</p><ol><li>计算机在内存中找到一个地址并将这个地址取值为book。</li><li>计算机在内存中找到能放下int[100]的地方，并记录数组首地址。</li><li>计算机将int[]首地址记录到book那一页。</li></ol><p>计算机查找数组中的元素过程如下：</p><ol><li>计算机找到book的地址。</li><li>在book中查找数组book[0]首地址。</li><li>将首地址加上数组的下标，找到要找的值。</li></ol><p>由此可以看出为什么数组下标是从“0”开始的，因为这样计算机查找的时候就直接加上下标数就行了，免去了一次减法的操作。</p><p>这种数据类型<strong>需要分两步查找</strong>，所以在Java中，这种数据类型<strong>不是</strong>Java的基本数据类型。</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】关于位运算</title>
    <link href="/2020/01/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2020/01/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>这几天重温Java，发现一个比较有意思的运算，位运算。</p><p>以前只在计算机组成原理这门课中学过位运算，一直以为学习位运算只是为了了解计算机的运算过程以及组成原理。没想到位运算在Java语言中也有很大的作用。</p><h2 id="位运算基础"><a href="#位运算基础" class="headerlink" title="位运算基础"></a>位运算基础</h2><p>位运算主要有三种运算，分别为“与(AND)”，“或(OR)”，“异或(XOR)”。</p><p>另外还有一个移位。</p><a id="more"></a><h2 id="位运算的应用"><a href="#位运算的应用" class="headerlink" title="位运算的应用"></a>位运算的应用</h2><p>位运算因为只有1和0，所以可以用于身份认证，这里举出一个判断身份的Java程序。</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BitChoose</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span></span>&#123;        <span class="hljs-keyword">int</span> base = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> is_student_mask = base; <span class="hljs-comment">//0001</span>        <span class="hljs-keyword">int</span> is_teacher_mask = base &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">//0010</span>        <span class="hljs-keyword">int</span> is_police_mask = base &lt;&lt; <span class="hljs-number">2</span>; <span class="hljs-comment">//0100</span>        <span class="hljs-keyword">int</span> is_doctor_mask = base &lt;&lt; <span class="hljs-number">3</span>; <span class="hljs-comment">//1000</span>        <span class="hljs-keyword">int</span> data = <span class="hljs-number">3</span>; <span class="hljs-comment">//0011</span>        <span class="hljs-keyword">boolean</span> is_student = (data &amp; is_student_mask) != <span class="hljs-number">0</span>;        System.out.println(is_student);        <span class="hljs-keyword">boolean</span> is_teacher = (data &amp; is_teacher_mask) != <span class="hljs-number">0</span>;        System.out.println(is_teacher);        <span class="hljs-keyword">boolean</span> is_police = (data &amp; is_police_mask) != <span class="hljs-number">0</span>;        System.out.println(is_police);        <span class="hljs-keyword">boolean</span> is_doctor = (data &amp; is_police_mask) != <span class="hljs-number">0</span>;        System.out.println(is_doctor);    &#125;&#125;</code></pre></div><p>可以看出位运算可以通过”掩码“和“与”运算实现身份识别功能。</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】动态规划</title>
    <link href="/2019/03/27/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2019/03/27/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p>假如有个小偷，背着可装4磅东西的背包，可盗窃的物品有如下三件：</p><table><thead><tr><th align="center">音响</th><th align="center">笔记本电脑</th><th align="center">吉他</th></tr></thead><tbody><tr><td align="center">3000美元</td><td align="center">2000美元</td><td align="center">1500美元</td></tr><tr><td align="center">4磅</td><td align="center">3磅</td><td align="center">1磅</td></tr></tbody></table><p>为了让盗窃的总价值最高，该选择哪些商品？</p><a id="more"></a><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p><strong>动态规划解法做成了如下的表格：</strong></p><table><thead><tr><th align="center"></th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">吉他</td><td align="center">1500美元(G)</td><td align="center">1500美元(G)</td><td align="center">1500美元(G)</td><td align="center">1500美元(G)</td></tr><tr><td align="center">音响</td><td align="center">1500美元(G)</td><td align="center">1500美元(G)</td><td align="center">1500美元(G)</td><td align="center">3000美元(S)</td></tr><tr><td align="center">笔记本电脑</td><td align="center">1500美元(G)</td><td align="center">1500美元(G)</td><td align="center">2000美元(L)</td><td align="center">3500美元(LG)</td></tr></tbody></table><p><strong>答案：将吉他和笔记本电脑装入背包时价值最高，为3500美元。</strong></p><p>计算每个单元格价值时，运用如下公式：</p><p>cell[i][j] =<br>max{ 上一个单元格的值(cell[i-1][j]) ，当前商品价值(cell[i][j-1])+剩余空间价值(cell[i-1][j-当前物品重量])</p><h2 id="代码表现"><a href="#代码表现" class="headerlink" title="代码表现"></a>代码表现</h2><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bag</span>(<span class="hljs-params">n,c,w,p</span>):</span>    res=[[<span class="hljs-number">-1</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(c+<span class="hljs-number">1</span>)]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>)]    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(c+<span class="hljs-number">1</span>):        <span class="hljs-comment">#第0行全部赋值为0，物品编号从1开始.为了下面赋值方便</span>        res[<span class="hljs-number">0</span>][j]=<span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,c+<span class="hljs-number">1</span>):            res[i][j]=res[i<span class="hljs-number">-1</span>][j]            <span class="hljs-keyword">print</span> res            <span class="hljs-comment">#生成了n*c有效矩阵，以下公式w[i-1],p[i-1]代表从第一个元素w[0],p[0]开始取。</span>            <span class="hljs-keyword">if</span>(j&gt;=w[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">and</span> res[i<span class="hljs-number">-1</span>][j-w[i<span class="hljs-number">-1</span>]]+p[i<span class="hljs-number">-1</span>]&gt;res[i][j]:                res[i][j]=res[i<span class="hljs-number">-1</span>][j-w[i<span class="hljs-number">-1</span>]]+p[i<span class="hljs-number">-1</span>]    <span class="hljs-keyword">return</span> res<span class="hljs-comment">#以下代码功能：标记出有放入背包的物品</span><span class="hljs-comment">#反过来标记，在相同价值情况下，后一件物品比前一件物品的最大价值大，则表示物品i#有被加入到背包，x数组设置为True。设初始为j=c。</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span>(<span class="hljs-params">n,c,w,res</span>):</span>    <span class="hljs-keyword">print</span> <span class="hljs-string">&#x27;最大价值为:&#x27;</span>,res[n][c]    x=[<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n)]    j=c    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):        <span class="hljs-keyword">if</span> res[i][j]&gt;res[i<span class="hljs-number">-1</span>][j]:            x[i<span class="hljs-number">-1</span>]=<span class="hljs-literal">True</span>            j-=w[i<span class="hljs-number">-1</span>]    <span class="hljs-keyword">print</span> <span class="hljs-string">&#x27;选择的物品为:&#x27;</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):        <span class="hljs-keyword">if</span> x[i]:            <span class="hljs-keyword">print</span> <span class="hljs-string">&#x27;第&#x27;</span>,i,<span class="hljs-string">&#x27;个,&#x27;</span>    <span class="hljs-keyword">print</span><span class="hljs-string">&#x27;&#x27;</span><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:    n=<span class="hljs-number">3</span>    c=<span class="hljs-number">4</span>    w=[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] <span class="hljs-comment">#这里重量要按从小到大排序</span>    p=[<span class="hljs-number">1500</span>,<span class="hljs-number">2000</span>,<span class="hljs-number">3000</span>]    res=bag(n,c,w,p)    show(n,c,w,res)</code></pre></div><p>理论上来说，第33行的重量无所谓顺序，但是此算法转化为代码时，因为代码的一些缺陷，导致必须要按从小到大排序才能使程序顺利运行。</p><h1 id="旅行行程最优化"><a href="#旅行行程最优化" class="headerlink" title="旅行行程最优化"></a>旅行行程最优化</h1><p>假设你要去伦敦度假，假期两天，你想去浏览的地方很多，但是没法全部浏览到，因此有如下的单子：</p><table><thead><tr><th align="center">名胜</th><th align="center">时间</th><th align="center">评分</th></tr></thead><tbody><tr><td align="center">威斯敏斯特教堂</td><td align="center">0.5天</td><td align="center">7</td></tr><tr><td align="center">环球剧场</td><td align="center">0.5天</td><td align="center">6</td></tr><tr><td align="center">英国国家美术馆</td><td align="center">1天</td><td align="center">9</td></tr><tr><td align="center">大英博物馆</td><td align="center">2天</td><td align="center">9</td></tr><tr><td align="center">圣保罗大教堂</td><td align="center">0.5天</td><td align="center">8</td></tr></tbody></table><p>这也可以转化为一个背包问题，可列出如下列表：</p><table><thead><tr><th align="center"></th><th align="center">1/2</th><th align="center">1</th><th align="center">3/2</th><th align="center">2</th></tr></thead><tbody><tr><td align="center">威斯敏斯特教堂(W)</td><td align="center">7(W)</td><td align="center">7(W)</td><td align="center">7(W)</td><td align="center">7(W)</td></tr><tr><td align="center">环球剧场(G)</td><td align="center">7(W)</td><td align="center">13(WG)</td><td align="center">13(WG)</td><td align="center">13(WG)</td></tr><tr><td align="center">英国国家美术馆(N)</td><td align="center">7(W)</td><td align="center">13(WG)</td><td align="center">16(WN)</td><td align="center">22(WGN)</td></tr><tr><td align="center">大英博物馆(B)</td><td align="center">7(W)</td><td align="center">13(WG)</td><td align="center">16(WN)</td><td align="center">22(WGN)</td></tr><tr><td align="center">圣保罗大教堂(S)</td><td align="center">7(W)</td><td align="center">15(WS)</td><td align="center">21(WGS)</td><td align="center">24(WNS)</td></tr></tbody></table><h1 id="动态规划问题特征"><a href="#动态规划问题特征" class="headerlink" title="动态规划问题特征"></a>动态规划问题特征</h1><ul><li>动态规划问题可以在给定约束条件下找到最优解。</li><li>问题可分解成彼此独立且离散的子问题时，就可使用动态规划来解决。</li><li>每种动态规划都涉及网格。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】近似算法</title>
    <link href="/2019/03/13/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/"/>
    <url>/2019/03/13/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h1><p>NP完全问题的定义就是以难解著称的问题，如旅行商问题和集合覆盖问题。很多人认为不可能编出快速解决这类问题的算法。</p><p>NP完全问题有以下几个特点：</p><ul><li>元素较少时算法运行速度非常快，随着元素增加，要考虑的情况急速增多，运行速度非常慢。</li><li>涉及“所有组合”的问题通常是NP完全问题。</li><li>不能将问题分成小问题，必须考虑各种可能的情况，这是通常是NP完全问题。</li><li>问题涉及序列且难以解决，可能是NP完全问题。</li><li>问题涉及集合且难以解决，可能是NP完全问题。</li><li>问题可转换为集合覆盖问题和旅行商问题，肯定是NP完全问题。</li></ul><p>虽然不能完美得解决这类问题，但是可以优秀得解决这类问题。通常使用的算法就是<strong>近似算法</strong>。</p><a id="more"></a><h1 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h1><p>贪婪算法是一种比较典型的<strong>近似算法</strong>。</p><p>原理很简单：</p><ol><li>找出最合适的。</li><li>找出第二合适的。</li><li>直到不能满足限定要求</li></ol><h1 id="集合覆盖问题"><a href="#集合覆盖问题" class="headerlink" title="集合覆盖问题"></a>集合覆盖问题</h1><p>如果有几个广播站可以覆盖一些地区，可能有重合，如何用最少的广播站覆盖最多的地区？</p><p>使用贪婪算法可以得到非常近似最优解的解。</p><ol><li>选出一个广播台，它覆盖了最多未覆盖的州。即使这个广播台覆盖了一些已经覆盖的州也没关系。</li><li>重复第一步。</li></ol><p>算法运行时间为O(n^2), n为广播台数量。</p><h2 id="代码表现"><a href="#代码表现" class="headerlink" title="代码表现"></a>代码表现</h2><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span>states_needed = set([<span class="hljs-string">&quot;mt&quot;</span>,<span class="hljs-string">&quot;wa&quot;</span>,<span class="hljs-string">&quot;or&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;nv&quot;</span>,<span class="hljs-string">&quot;ut&quot;</span>,<span class="hljs-string">&quot;ca&quot;</span>,<span class="hljs-string">&quot;az&quot;</span>]) <span class="hljs-comment"># 输入所有地区</span>stations = &#123;&#125; <span class="hljs-comment">#用散列表表示电台</span>stations[<span class="hljs-string">&quot;kone&quot;</span>] = set([<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;nv&quot;</span>,<span class="hljs-string">&quot;ut&quot;</span>]) <span class="hljs-comment">#将数组转换为集合</span>stations[<span class="hljs-string">&quot;ktwo&quot;</span>] = set([<span class="hljs-string">&quot;wa&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;mt&quot;</span>])stations[<span class="hljs-string">&quot;kthree&quot;</span>] = set([<span class="hljs-string">&quot;or&quot;</span>,<span class="hljs-string">&quot;nv&quot;</span>,<span class="hljs-string">&quot;ca&quot;</span>])stations[<span class="hljs-string">&quot;kfour&quot;</span>] = set([<span class="hljs-string">&quot;nv&quot;</span>,<span class="hljs-string">&quot;ut&quot;</span>])stations[<span class="hljs-string">&quot;kfive&quot;</span>] = set([<span class="hljs-string">&quot;ca&quot;</span>,<span class="hljs-string">&quot;az&quot;</span>])final_station = set() <span class="hljs-comment">#最终选择广播台</span><span class="hljs-keyword">while</span> states_needed:    best_station = <span class="hljs-literal">None</span>    states_covered = set()    <span class="hljs-keyword">for</span> station, states <span class="hljs-keyword">in</span> stations.items():        covered = states_needed &amp; states <span class="hljs-comment"># 计算交集</span>        <span class="hljs-keyword">if</span> len(covered) &gt; len(states_covered):            best_station = station            states_covered = covered    states_needed -= states_covered <span class="hljs-comment">#剔除覆盖的地区</span>    final_station.add(best_station)<span class="hljs-keyword">print</span> final_station</code></pre></div><p>得到结果<code>set([&#39;ktwo&#39;, &#39;kthree&#39;, &#39;kone&#39;, &#39;kfive&#39;])</code></p>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
      <tag>近似算法</tag>
      
      <tag>最适化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】狄克斯特拉算法</title>
    <link href="/2019/03/12/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/"/>
    <url>/2019/03/12/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>广度优先搜索可以寻找到不带权值的最短路径，但是路径带权值的话就不可以使用广度优先搜索找最短路径了，所以我们使用狄克斯特拉算法算法来解决带权值的最短路径问题。  </p><p>具体算法步骤如下：</p><ol><li>找出最便宜的节点，即可在最短时间内前往的节点。</li><li>对于该节点的邻居，检查是否有前往它们的最短路径，如果有，就更新其开销。</li><li>重复这个过程，直到堆图中每个节点都这样做了。</li><li>计算最终路径。</li></ol><p><strong>注意</strong>：狄克斯特拉算法只支持<strong>有向无环图</strong>。当边的权值有负数时，也不可以使用狄克斯特拉算法。</p><a id="more"></a><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p>解决这个问题需要三个散列表，一个保存图的结构，一个保存最小开销，一个保存父节点。</p><p>具体代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><span class="hljs-comment"># 将图用散列表表示</span>graph = &#123;&#125;graph[<span class="hljs-string">&quot;start&quot;</span>] = &#123;&#125;graph[<span class="hljs-string">&quot;start&quot;</span>][<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">6</span>graph[<span class="hljs-string">&quot;start&quot;</span>][<span class="hljs-string">&quot;b&quot;</span>] = <span class="hljs-number">2</span>graph[<span class="hljs-string">&quot;a&quot;</span>] = &#123;&#125;graph[<span class="hljs-string">&quot;a&quot;</span>][<span class="hljs-string">&quot;fin&quot;</span>] = <span class="hljs-number">1</span>graph[<span class="hljs-string">&quot;b&quot;</span>] = &#123;&#125;graph[<span class="hljs-string">&quot;b&quot;</span>][<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">3</span>graph[<span class="hljs-string">&quot;b&quot;</span>][<span class="hljs-string">&quot;fin&quot;</span>] = <span class="hljs-number">5</span>graph[<span class="hljs-string">&quot;fin&quot;</span>] =&#123;&#125;<span class="hljs-comment">#将最小开销用散列表表示</span>infinity = float(<span class="hljs-string">&quot;inf&quot;</span>)costs = &#123;&#125;costs[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">6</span>costs[<span class="hljs-string">&quot;b&quot;</span>] = <span class="hljs-number">2</span>costs[<span class="hljs-string">&quot;fin&quot;</span>] = infinity<span class="hljs-comment">#将父节点用散列表表示</span>parents = &#123;&#125;parents[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-string">&quot;start&quot;</span>parents[<span class="hljs-string">&quot;b&quot;</span>] = <span class="hljs-string">&quot;start&quot;</span>parents[<span class="hljs-string">&quot;fin&quot;</span>] = <span class="hljs-literal">None</span>processed = [] <span class="hljs-comment">#标记处理过的节点</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_lowest_cost_node</span>(<span class="hljs-params">costs</span>):</span>    lowest_cost = float(<span class="hljs-string">&quot;inf&quot;</span>)    lowest_cost_node = <span class="hljs-literal">None</span>    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> costs: <span class="hljs-comment"># 遍历所有节点</span>        cost = costs[node]        <span class="hljs-keyword">if</span> cost &lt; lowest_cost <span class="hljs-keyword">and</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> processed: <span class="hljs-comment">#如果该节点开销更低且没处理过</span>            lowest_cost = cost <span class="hljs-comment"># 将其作为开销最低的节点</span>            lowest_cost_node = node    <span class="hljs-keyword">return</span> lowest_cost_nodenode = find_lowest_cost_node(costs)<span class="hljs-comment">#在未处理的节点中找到开销最小的节点</span><span class="hljs-keyword">while</span> node <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>: <span class="hljs-comment"># 循环在所有节点被处理后结束</span>    cost = costs[node]    neighbors = graph[node]    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> neighbors.keys(): <span class="hljs-comment"># 遍历当前节点的所有邻居</span>        new_cost = cost + neighbors[n]        <span class="hljs-keyword">if</span> costs[n] &gt; new_cost: <span class="hljs-comment"># 如果当前节点开销更小</span>            costs[n] = new_cost <span class="hljs-comment"># 更新邻居开销</span>            parents[n] = node <span class="hljs-comment"># 将该邻居父节点设为当前节点</span>    processed.append(node) <span class="hljs-comment"># 标记用过的节点</span>    node = find_lowest_cost_node(costs)<span class="hljs-keyword">print</span> parents<span class="hljs-keyword">print</span> costs</code></pre></div><p>得到结果：</p><div class="hljs code-wrapper"><pre><code class="hljs 1c">&#123;&#x27;a&#x27;: &#x27;b&#x27;, &#x27;b&#x27;: &#x27;start&#x27;, &#x27;fin&#x27;: &#x27;a&#x27;&#125;&#123;&#x27;a&#x27;: <span class="hljs-number">5</span>, &#x27;b&#x27;: <span class="hljs-number">2</span>, &#x27;fin&#x27;: <span class="hljs-number">6</span>&#125;</code></pre></div><table><thead><tr><th align="center">子节点</th><th align="center">父节点</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">b</td></tr><tr><td align="center">b</td><td align="center">start</td></tr><tr><td align="center">fin</td><td align="center">a</td></tr></tbody></table><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>广度优先搜索用于在非加权图中查找最短路径。</li><li>狄克斯特拉算法用于在加权图中查找最短路径。</li><li>仅当权重为正时狄克斯特拉算法才管用。</li><li>如果图中包含负权边，请使用贝尔曼-福德算法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】广度优先搜索</title>
    <link href="/2019/03/06/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2019/03/06/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>广度优先搜索可以回答两类问题：</p><ol><li>从节点A出发，有前往节点B的路径吗？</li><li>从节点A出发，前往节点B哪条路径最短？</li></ol><a id="more"></a><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>广度优先算法通过<strong>队列</strong>来实现，<strong>队列是一种先进先出结构</strong>。具体操作如下：</p><ol><li>先将图用散列表表示</li><li>创建队列，将所有邻居都加入到队列当中。</li><li>从第一层邻居关系开始搜索，直到所有邻居都搜索完。</li><li>返回结果</li></ol><h1 id="代码表现"><a href="#代码表现" class="headerlink" title="代码表现"></a>代码表现</h1><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> dequegraph = &#123;&#125;graph[<span class="hljs-string">&quot;you&quot;</span>] = [<span class="hljs-string">&quot;alice&quot;</span>,<span class="hljs-string">&quot;bob&quot;</span>,<span class="hljs-string">&quot;claire&quot;</span>]graph[<span class="hljs-string">&quot;bob&quot;</span>] = [<span class="hljs-string">&quot;anuj&quot;</span>,<span class="hljs-string">&quot;peggy&quot;</span>]graph[<span class="hljs-string">&quot;alice&quot;</span>] = [<span class="hljs-string">&quot;peggy&quot;</span>]graph[<span class="hljs-string">&quot;claire&quot;</span>] = [<span class="hljs-string">&quot;thom&quot;</span>,<span class="hljs-string">&quot;jonny&quot;</span>]graph[<span class="hljs-string">&quot;anuj&quot;</span>] = []graph[<span class="hljs-string">&quot;peggy&quot;</span>] = []graph[<span class="hljs-string">&quot;thom&quot;</span>] = []graph[<span class="hljs-string">&quot;jonny&quot;</span>] = []<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">name</span>):</span>    search_queue = deque()    search_queue += graph[name]    searched = []  <span class="hljs-comment">#用于记录已经观察过的人</span>    <span class="hljs-keyword">while</span> search_queue:        person = search_queue.popleft()        <span class="hljs-keyword">if</span> person <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> searched:            <span class="hljs-keyword">if</span> person_is_seller(person):                <span class="hljs-keyword">print</span> person + <span class="hljs-string">&quot;is a mango seller&quot;</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            <span class="hljs-keyword">else</span>:                search_queue += graph[person]                searched.append(person)  <span class="hljs-comment">#标记这个人已经检查过</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">person_is_seller</span>(<span class="hljs-params">name</span>):</span>    <span class="hljs-keyword">return</span> name[<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;m&#x27;</span>search(<span class="hljs-string">&quot;you&quot;</span>)</code></pre></div><h1 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h1><p>广度优先沿着每条边前行，然后将每个人加入队列中检查，所以运行时间为O(边数+人数)，通常写做O(V+E)。</p>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】散列表</title>
    <link href="/2019/03/03/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <url>/2019/03/03/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><p>当要快速查找一样水果的价格时，可以用前面所学的二分查找来进行查找，但是二分查找的运行时间虽然为O(log n)但是总归会随着元素数量增加而拖慢查找速度。</p><p>所以数据结构中引入了<strong>散列表</strong>,散列表的运行时间始终为O(1)，是比较理想的数据存储方式。</p><a id="more"></a><p>散列表的数据存储原理如下：</p><ol><li>创建一个合适的空数组。</li><li>将输入的值用链表的方式加入数组中。</li><li>如果散列表中<strong>填装因子</strong>过大，则扩大数组（一般扩大两倍）。</li></ol><p>以上所说的<strong>填装因子</strong>为：（散列表包含的元素数/位置总数）一般填装因子临界值设置为0.7。</p><p>回到一开始的问题，假如苹果价钱是0.67，牛奶的价格是1.49，鳄梨价格是1.49，要快速查找各个水果价格可以用散列表。</p><p>虽然散列表自己实现比较难，但是任何主流语言都提供了散列表的实现，python提供的散列表实现为<strong>字典</strong>。</p><div class="hljs code-wrapper"><pre><code class="hljs python">&gt;&gt;&gt;book = dict()&gt;&gt;&gt;book[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">0.67</span>&gt;&gt;&gt;book[<span class="hljs-string">&quot;milk&quot;</span>] = <span class="hljs-number">1.49</span>&gt;&gt;&gt;book[<span class="hljs-string">&quot;avocado&quot;</span>] + <span class="hljs-number">1.49</span>&gt;&gt;&gt;<span class="hljs-keyword">print</span> book</code></pre></div><p>如果要查询鳄梨的价格，我们只需输入<code>print book[&quot;avocado&quot;]</code>即可。</p><h1 id="散列表的应用"><a href="#散列表的应用" class="headerlink" title="散列表的应用"></a>散列表的应用</h1><h2 id="用于查找"><a href="#用于查找" class="headerlink" title="用于查找"></a>用于查找</h2><p>手机内置电话簿就可使用散列表实现，具体实现代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs python">&gt;&gt;&gt;phone_book = dict() <span class="hljs-comment">#亦可使用phone_book = &#123;&#125;</span>&gt;&gt;&gt;phone_book[<span class="hljs-string">&quot;jenny&quot;</span>] = <span class="hljs-number">8675309</span>&gt;&gt;&gt;phone_book[<span class="hljs-string">&quot;emergency&quot;</span>] = <span class="hljs-number">110</span></code></pre></div><p>现在要查找jenny的电话号码，只需输入<code>print phone_book[&quot;jenny&quot;]</code>即可得出jenny的电话号。</p><p>还有DNS解析也使用了散列表。</p><h2 id="防止重复"><a href="#防止重复" class="headerlink" title="防止重复"></a>防止重复</h2><p>投票中，要知道一个人是否已经投过票需要查找一串长长的名单，但是运用散列表就可以很快的查处一个人是否已经投过票。</p><div class="hljs code-wrapper"><pre><code class="hljs python">voted = &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_voter</span>(<span class="hljs-params">name</span>):</span>    <span class="hljs-keyword">if</span> voted.get(name):        <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;kick him out!&quot;</span>    <span class="hljs-keyword">else</span>:        voted[name] = <span class="hljs-literal">True</span>        <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;let him vote!&quot;</span>check_voter(<span class="hljs-string">&quot;tom&quot;</span>)check_voter(<span class="hljs-string">&quot;mike&quot;</span>)check_voter(<span class="hljs-string">&quot;tom&quot;</span>)</code></pre></div><p>输出结果为：</p><div class="hljs code-wrapper"><pre><code class="hljs result">let him vote!let him vote!kick him out!</code></pre></div><p>如果存储在列表中，运用简单查找速度将非常慢，存储在散列表中，查询速度非常快。</p><h2 id="用于缓存"><a href="#用于缓存" class="headerlink" title="用于缓存"></a>用于缓存</h2><p>当你第一次进入网页时，服务器需要做大量的查找工作，如果每次进网页都交由服务器处理，那么服务器将不堪重负，所以当你第一次进入网页中时，服务器处理后会生成一个散列表在缓存上，当你再次进入相同的页面时，就不用通过服务器处理，直接调用散列表中的缓存的数据就可以快速访问网页，大大提高了服务器的运行效率。</p><p>具体代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs python">cache = &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_page</span>(<span class="hljs-params">url</span>):</span><span class="hljs-keyword">if</span> cache.get(url):<span class="hljs-keyword">return</span> cache[url]<span class="hljs-keyword">else</span>:data = get_data_from_server(url)cache[url] = data<span class="hljs-keyword">return</span> data</code></pre></div><h1 id="散列表性能"><a href="#散列表性能" class="headerlink" title="散列表性能"></a>散列表性能</h1><p>根据散列表特性，最好的情况为O(1),最坏的情况为O(n),所以当填装因子过大时，为了防止<strong>冲突</strong>，我们需要对散列表进行扩容，虽然调整散列表长度开销很大，但是就整体而言，散列表的整体运行时间依然是O(1)。</p><h1 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h1><p>散列函数作为非基础模块，本章不做解释，具体可以了解SHA函数和MD5算法。</p>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】快速排序</title>
    <link href="/2019/03/02/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/03/02/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h1><p>假如有一块长方形土地，要将土地均匀分成方块，而且方块要尽可能大，如何分呢？</p><p><strong>D&amp;C策略</strong></p><ol><li>找出长方形地块的宽作为分割出正方形的边长，分割出正方形。</li><li>剩下来不能分割的部分继续用第一步进行分割。</li><li>直到能分割成全部正方形。</li><li>返回结果，结束程序。</li></ol><p>此问题中基线条件为<strong>一条边长度是另一条边的整数倍</strong>。</p><a id="more"></a><p><strong>D&amp;C原理</strong></p><ol><li>找出简单的基线条件</li><li>确定如何缩小问题规模，使其符合基线条件。</li></ol><p>再来看一个问题，<strong>求2+4+6的和</strong>。</p><ol><li>找出基线条件。此问题的基线条件是<strong>数组中只包含一个数字</strong>，则计算容易许多。</li><li>将sum([2,4,6])的第一个数拆分出来，变为2+sum([4,6])</li><li>重复第二步，直到sum()中只有一个元素。</li><li>在调用栈中返回结果。</li><li>结束。</li></ol><p>代码表现为：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x</span>):</span>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">2</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> x + sum(x - <span class="hljs-number">2</span>)<span class="hljs-keyword">print</span> sum(<span class="hljs-number">6</span>)</code></pre></div><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序也运用了D&amp;C，其原理如下：</p><ol><li>找出其中一个数，拿左右相邻数与这个数比较，把所有小于基准值的放到左边，大于基准值的放到右边。</li><li>左边和右边同时重复第一步。</li><li>直到数组长度为1</li><li>调用栈返回值。</li><li>结束程序。</li></ol><p>代码表现如下：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quicksort</span>(<span class="hljs-params">array</span>):</span>    <span class="hljs-keyword">if</span> len(array) &lt; <span class="hljs-number">2</span>: <span class="hljs-comment">#基线条件</span>        <span class="hljs-keyword">return</span> array    <span class="hljs-keyword">else</span>:        pivot = array[<span class="hljs-number">0</span>]        less = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &lt;= pivot] <span class="hljs-comment">#由所有小于等于基准值组成的子数组</span>        greater = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &gt; pivot] <span class="hljs-comment">#由所有大于基准值组成的子数组</span>        <span class="hljs-keyword">return</span> quicksort(less) + [pivot] + quicksort(greater)<span class="hljs-keyword">print</span> quicksort([<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】递归和栈</title>
    <link href="/2019/03/01/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%80%92%E5%BD%92%E5%92%8C%E6%A0%88/"/>
    <url>/2019/03/01/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%80%92%E5%BD%92%E5%92%8C%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>如果有一个盒子，盒子里有盒子，盒子里的盒子也有盒子，那么，怎样在一堆盒子里找出钥匙呢？</p><p><strong>方法一</strong>  </p><ol><li>创建一个要找的盒子堆。</li><li>从盒子里找出一个盒子，打开。</li><li>如果是盒子，就放入盒子堆，以后再查找。</li><li>如果是钥匙，结束返回。</li><li>回到第二步。</li></ol><a id="more"></a><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">look_for_key</span>(<span class="hljs-params">main_box</span>):</span>    pile = main_box.make_a_pile_to_look_through()    <span class="hljs-keyword">while</span> pile <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> empty:        box = pile.grab_a_box()        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> box:            <span class="hljs-keyword">if</span> item.is_a_box():                pile.append(item)            <span class="hljs-keyword">elif</span> item.is_a_key():                <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;find the key!&quot;</span></code></pre></div><p><strong>方法二</strong></p><ol><li>检查盒子里面东西。</li><li>如果是盒子，返回第一步。</li><li>如果是钥匙，结束返回。</li></ol><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">look_for_key</span>(<span class="hljs-params">box</span>):</span>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> box:        <span class="hljs-keyword">if</span> item.is_a_box(): <span class="hljs-comment">#递归条件</span>            look_for_key(item)        <span class="hljs-keyword">elif</span> item.is_a_key(): <span class="hljs-comment">#基线条件</span>            <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;find the key!&quot;</span></code></pre></div><p>第二种方法就使用了递归，自己调用自己。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>一个简单函数：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">name</span>):</span><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;hello,&quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>greet2(name)<span class="hljs-keyword">print</span> <span class="hljs-string">&quot;greeting ready to say bye...&quot;</span>bye()</code></pre></div><p>这个函数调用了两个函数，两个函数代码如下：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greeet2</span>(<span class="hljs-params">name</span>):</span><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;how are you,&quot;</span> + name + <span class="hljs-string">&quot;?&quot;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bye</span>():</span><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;ok bye!&quot;</span></code></pre></div><p>在内存中，这个函数运行过程如下：</p><ol><li>greet()被压入栈底部。</li><li>greet2()被压入greet()上方。</li><li>打印出greet2()结果。</li><li>在栈中弹出greet2()。</li><li>bye()被压入greet()上方。</li><li>打印出bye()结果。</li><li>greet()返回。</li></ol><p>这个栈用于存储多个函数的变量，被称为<strong>调用栈</strong>。所有函数调用都进入调用栈。</p><h1 id="递归调用栈"><a href="#递归调用栈" class="headerlink" title="递归调用栈"></a>递归调用栈</h1><p>给定函数factorial(5)写做5!=5*4*3*2*1，那么：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fact</span>(<span class="hljs-params">x</span>):</span><span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">1</span><span class="hljs-keyword">else</span>:<span class="hljs-keyword">return</span> x*fact(x<span class="hljs-number">-1</span>)</code></pre></div><p>fact(3)的调用栈变化如下：</p><ol><li>搭积木，最下层放入x=3，其上依次为x=2，x=1。</li><li>x=1满足结束条件，返回1，并弹出x=1的栈。</li><li>返回2*1，弹出x=2的栈。</li><li>返回3*2，结束程序。</li></ol><p>栈使用理解方便，但是占用内存大。栈太高时，可以转用循环。</p>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】选择排序</title>
    <link href="/2019/02/28/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/02/28/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="算法表现"><a href="#算法表现" class="headerlink" title="算法表现"></a>算法表现</h1><p>选择排序是基础排序算法，运行时间较长，具体算法表现如下：</p><ol><li><strong>遍历整个数组</strong>，找出最大（最小）值，弹出原数组并将其放入新数组中。</li><li><strong>遍历剩余元素</strong>，找出最大（最小）值，弹出原数组并放入新数组中前一个数之后。</li><li>重复第二步，得到新数组，排序完成。</li></ol><a id="more"></a><h1 id="代码表现"><a href="#代码表现" class="headerlink" title="代码表现"></a>代码表现</h1><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findSmallest</span>(<span class="hljs-params">arr</span>):</span>    Smallest = arr[<span class="hljs-number">0</span>]    Smallest_index = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(arr)):        <span class="hljs-keyword">if</span> arr[i] &lt; Smallest:            Smallest = arr[i]            Smallest_index = i    <span class="hljs-keyword">return</span> Smallest_index<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selectionSort</span>(<span class="hljs-params">arr</span>):</span>    newArr = []    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(arr)):        smallest = findSmallest(arr)        newArr.append(arr.pop(smallest))<span class="hljs-comment">#append()给新数组添加元素，pop()将该元素弹出原数组</span>    <span class="hljs-keyword">return</span> newArr<span class="hljs-keyword">print</span> selectionSort([<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">10</span>])</code></pre></div><h1 id="算法运行时间"><a href="#算法运行时间" class="headerlink" title="算法运行时间"></a>算法运行时间</h1><p>第一次需要检查n个元素，随后依次是n-1，n-2，···，2和1。因此运行时间为O(n*1/2*n)，但是大O表示法常常省略1/2这样的常数，所以选择排序的算法运行时间为O(n^2).</p>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】二分查找</title>
    <link href="/2019/02/27/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2019/02/27/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="算法表现"><a href="#算法表现" class="headerlink" title="算法表现"></a>算法表现</h1><p>二分查找是计算机学习中比较基础的算法，具体算法表现如下：</p><ol><li><strong>排序</strong>，将要查找的一串数字从小到大或者从大到小进行排序。</li><li><strong>寻找该数字位置</strong>，取出正中间的数字，与要查找的数字比大小，大了就扔掉后面的一串数字，小了就扔掉前面的一串数字</li><li>重复第二步，直到找到想要的数字。</li></ol><a id="more"></a><h1 id="代码表现"><a href="#代码表现" class="headerlink" title="代码表现"></a>代码表现</h1><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span>(<span class="hljs-params">list, item</span>):</span>    list.sort()    <span class="hljs-keyword">print</span> list    low = <span class="hljs-number">0</span>    high = len(list) - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span> low &lt;= high:        mid = (low + high) / <span class="hljs-number">2</span>        guess = list[mid]        <span class="hljs-keyword">if</span>  guess == item:            <span class="hljs-keyword">return</span> mid        <span class="hljs-keyword">if</span> guess &gt; item:            high = mid - <span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            low = mid + <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>my_list = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">19</span>,<span class="hljs-number">15</span>,<span class="hljs-number">13</span>,<span class="hljs-number">17</span>,<span class="hljs-number">11</span>]<span class="hljs-keyword">print</span> binary_search(my_list,<span class="hljs-number">3</span>)<span class="hljs-keyword">print</span> binary_search(my_list,<span class="hljs-number">-1</span>)</code></pre></div><h1 id="算法运行时间"><a href="#算法运行时间" class="headerlink" title="算法运行时间"></a>算法运行时间</h1><p><strong>大O表示法</strong>，O表示的是操作数</p><ul><li>O(log n),对数时间，比如二分查找</li><li>O(n),线性时间，比如简单查找</li><li>O(n*logn)，快速排序</li><li>O(n^2)，选择排序</li><li>O(n!)，旅行商问题解决方法</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【network实践】DHCP和NAT</title>
    <link href="/2018/12/17/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9ADHCP%E5%92%8CNAT/"/>
    <url>/2018/12/17/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9ADHCP%E5%92%8CNAT/</url>
    
    <content type="html"><![CDATA[<h1 id="DHCP概要"><a href="#DHCP概要" class="headerlink" title="DHCP概要"></a>DHCP概要</h1><p>DHCP(dynamic host configuration protocol)是局域网中的一种协议，可以给内部网自动分配ip地址。  </p><p>DHCP客户端和DHCP服务器之间连接过程分为四步：  </p><ol><li>discovery阶段：客户端通过broadcast寻找服务器</li><li>offer阶段：服务器预约ip地址并回信给客户端</li><li>request阶段：客户端收到offer，并将需要的ip地址，broadcast告诉服务器</li><li>ack阶段：服务器按照要求给客户端分配ip地址</li></ol><a id="more"></a><h1 id="NAT概要"><a href="#NAT概要" class="headerlink" title="NAT概要"></a>NAT概要</h1><p>NAT(network address translation)相当于在外部的网络记住内部网络的网络端口，从而可以在ip地址一直变化的情况下做到准确运输数据包。  </p><p><strong>NAT有两个优点：</strong>  </p><ol><li>可以解决ipv4地址枯竭的问题。</li><li>可以提高网络的安全性。</li></ol><p><strong>几个需要注意的NAT用语：</strong></p><ul><li>内部local address：从内部往内部看ip地址。</li><li>内部global address：从外部向内部看ip地址。</li><li>外部local address：从内部看外部的ip地址。</li><li>外部global address：从外部看外部的ip地址。</li></ul><p>NAT内部local address和内部global address是一一对应的关系：  </p><ul><li>10.1.1.1 – 1.1.1.1</li><li>10.1.1.2 – 1.1.1.2</li><li>10.1.1.3 – 1.1.1.3</li><li>10.1.1.4 – 1.1.1.4</li></ul><h1 id="PAT概要"><a href="#PAT概要" class="headerlink" title="PAT概要"></a>PAT概要</h1><p>PAT(port address translation)是局域网中的一种协议，与NAT不同的是，PAT可以就一个ip地址通过分配不同的网口的形式，实现只用一个内部global address分配到不同的内部local address。</p><ul><li>10.1.1.1:1025 – 1.1.1.1:1025</li><li>10.1.1.2:1029 – 1.1.1.1:1029</li><li>10.1.1.5:1030 – 1.1.1.1:1030</li></ul><h1 id="演习"><a href="#演习" class="headerlink" title="演习"></a>演习</h1><p>network拓扑图如下,要求用两台router，一台switch完成实验，从ISP路由器出发分割出的global地址是209.165.200.224/29，利用此global地址设定GW路由器的PAT，内部IP地址根据192.168.32.0/24的范围进行DHCP分配地址,PC取得适当的ip地址后，模拟网络服务(loopback)能完成通信的话就是成功。</p><p><img src="/images/DHCP.jpg">  </p><p><strong>首先配置GW的路由器NAT：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs C">GW_Router(config)<span class="hljs-meta">#interface fastethernet 0</span>GW_Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#ip address 192.168.32.254 255.255.255.0</span>GW_Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#ip nat inside</span>GW_Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#no shutdown</span>GW_Router(config)<span class="hljs-meta">#interface fastethernet 1</span>GW_Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#ip address 209.165.201.18 255.255.255.0</span>GW_Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#ip nat outside</span>GW_Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#no shutdown</span>GW_Router(config)<span class="hljs-meta">#ip nat pool DPAT 209.165.201.209 209.165.201.230 netmask 255.255.255.0</span>GW_Router(config)<span class="hljs-meta">#access-list 1 permit host 192.168.32.0  <span class="hljs-comment">//设置ACL</span></span>GW_Router(config)<span class="hljs-meta">#ip nat inside source list 1 pool DPAT overload <span class="hljs-comment">//PAT定义</span></span></code></pre></div><p><strong>其次配置GW路由器DHCP：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs C">GW_Router(config)<span class="hljs-meta">#ip dhcp excluded-address 192.168.32.10 192.168.32.254<span class="hljs-comment">//192.168.32.10-254除外</span></span>GW_Router(config)<span class="hljs-meta">#ip dhcp pool LANUser</span>GW_Router(dhcp-config)<span class="hljs-meta">#network 192.168.32.0 255.255.255.0</span>GW_Router(dhcp-config)<span class="hljs-meta">#default-router 192.168.32.254</span>GW_Router(dhcp-config)<span class="hljs-meta">#domain-name google.com</span>GW_Router(dhcp-config)<span class="hljs-meta">#dns-server 8.8.8.8 <span class="hljs-comment">//设定dns服务器</span></span>GW_Router(dhcp-config)<span class="hljs-meta">#lease 0 12 <span class="hljs-comment">//释放时间设置为12小时</span></span>GW_Router(config)<span class="hljs-meta">#ip route 0.0.0.0 0.0.0.0 209.165.201.17<span class="hljs-comment">//设定GW路由到ISP路由的默认路由通路</span></span></code></pre></div><p><strong>接着配置ISP服务器：</strong></p><div class="hljs code-wrapper"><pre><code class="hljs C">ISP_Router(config)<span class="hljs-meta">#interface fastethernet 0</span>ISP_Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#ip address 209.165.201.17 255.255.255.0</span>ISP_Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#no shutdown</span>ISP_Router(config)<span class="hljs-meta">#interface loopback 0</span>ISP_Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#ip address 8.8.8.8 255.255.255.0</span>ISP_Router(config)<span class="hljs-meta">#ip route 209.165.200.224 255.255.255.248 209.165.201.18</span>ISP_Router<span class="hljs-meta">#show ip route</span></code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此所有NAT配置完成，但是最终<code>show ip nat translations</code>什么也不显示，原因是设置完后没有运行，这时用PC<code>ping 8.8.8.8</code>就可以查看设置是否成功，<code>show ip nat translations</code>也会显示内容。  </p><p>有一个小疑问<code>GW_Router(config)#ip route 0.0.0.0 0.0.0.0 209.165.201.17</code>这个语句为什么是从default gateway出发？</p>]]></content>
    
    
    <categories>
      
      <category>network实践笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>cisco</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【network实践】access和trunk配置</title>
    <link href="/2018/12/06/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9Aaccess%E5%92%8Ctrunk%E9%85%8D%E7%BD%AE/"/>
    <url>/2018/12/06/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9Aaccess%E5%92%8Ctrunk%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="access"><a href="#access" class="headerlink" title="access"></a>access</h1><p>当Switch划分成几个不同的vlan时，怎样解决不同vlan内部的通信问题呢？这时我们就需要access来帮助我们进行内部的通信，这样就可以在一台switch中划分出很多vlan，各个vlan之间相互隔离不能通信。<br><strong>access只能解决同网段同vlan的互通问题，不能解决不同网段的vlan互通问题</strong> ，比如192.168.1.1和192.168.2.1即使被access划分进了一个vlan也不能相互通信。</p><a id="more"></a><h2 id="access演习"><a href="#access演习" class="headerlink" title="access演习"></a>access演习</h2><p>将switch进行如下设置：</p><blockquote><ul><li>Fa 0/1 - 8 =&gt; VLAN 10</li><li>Fa 0/9 - 16 =&gt; VLAN 20</li><li>四台电脑之间通信确认</li></ul></blockquote><h3 id="配置SWITCH"><a href="#配置SWITCH" class="headerlink" title="配置SWITCH"></a>配置SWITCH</h3><div class="hljs code-wrapper"><pre><code class="hljs C">Switch(config)<span class="hljs-meta">#interface range fastethernet 0/1 - 8</span>Switch(config-<span class="hljs-keyword">if</span>-range)<span class="hljs-meta">#switchport mode access</span>Switch(config-<span class="hljs-keyword">if</span>-range)<span class="hljs-meta">#switchport access vlan 10</span>Switch(config)<span class="hljs-meta">#interface range fastethernet 0/9 - 16</span>Switch(config-<span class="hljs-keyword">if</span>-range)<span class="hljs-meta">#switchport mode access</span>Switch(config-<span class="hljs-keyword">if</span>-range)<span class="hljs-meta">#switchport access vlan 20</span></code></pre></div><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>至此access配置完成，结果是vlan10接口之间可以相互通信，vlan20接口之间可以相互通信，vlan10接口与vlan20接口即使切换成同一网段也无法实现通信。</p><h1 id="trunk"><a href="#trunk" class="headerlink" title="trunk"></a>trunk</h1><p>第一章我们解决了同一台switch之间不同vlan的划分，然而两台甚至多台switch如何解决通信呢？这就需要trunk来解决问题，trunk可以解决两台switch设置成同一vlan之间的通信问题。</p><h2 id="trunk演习"><a href="#trunk演习" class="headerlink" title="trunk演习"></a>trunk演习</h2><p>将两台switch进行如下设定：</p><ul><li>Fa 0/1 - 8 =&gt; VLAN 10</li><li>Fa 0/9 - 16 =&gt; VLAN 20</li><li>Fa 0/24 为trunk口</li><li>vlan10的PC分为192.168.10.1和192.168.10.2</li><li>vlan20的PC分为192.168.20.12和192.168.20.13</li><li>switchport通信确认<ul><li>switchport 1和switchport 2</li><li>switchport 1和switchport 13</li><li>switchport 12和switchport 13</li></ul></li></ul><h3 id="配置switch的access"><a href="#配置switch的access" class="headerlink" title="配置switch的access"></a>配置switch的access</h3><div class="hljs code-wrapper"><pre><code class="hljs C">Switch(config)<span class="hljs-meta">#interface range fastethernet 0/1 - 8</span>Switch(config-<span class="hljs-keyword">if</span>-range)<span class="hljs-meta">#switchport mode access</span>Switch(config-<span class="hljs-keyword">if</span>-range)<span class="hljs-meta">#switchport access vlan 10</span>Switch(config)<span class="hljs-meta">#interface range fastethernet 0/9 - 16</span>Switch(config-<span class="hljs-keyword">if</span>-range)<span class="hljs-meta">#switchport mode access</span>Switch(config-<span class="hljs-keyword">if</span>-range)<span class="hljs-meta">#switchport access vlan 20</span></code></pre></div><h3 id="配置trunk"><a href="#配置trunk" class="headerlink" title="配置trunk"></a>配置trunk</h3><div class="hljs code-wrapper"><pre><code class="hljs C">SW1(config)<span class="hljs-meta">#interface range fastethernet 0/24</span>SW1(config-<span class="hljs-keyword">if</span>-range)<span class="hljs-meta">#switchport trunk encapsulation dot1q</span>SW1(config-<span class="hljs-keyword">if</span>-range)<span class="hljs-meta">#switchport nonegotiate</span></code></pre></div><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>两台switch之间vlan10和vlan20可以分别相互通信。</p>]]></content>
    
    
    <categories>
      
      <category>network实践笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>cisco</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【network实践】单臂路由的实现</title>
    <link href="/2018/12/05/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2018/12/05/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>vlan間ルーティング（ROUTER ON A STICK,单臂路由）在很多博客上都有记录，物理上的要实现两个不同网段的互联的拓扑图如下</p><a id="more"></a><p><img src="/images/%E6%BC%94%E4%B9%A01%E6%8B%93%E6%89%91%E5%9B%BE.jpg"><br>但是现在只需要一台路由器和一台switch通过access和trunk制造虚拟的网口就可实现两个不同网段在同一台switch上的互联。  </p><h2 id="演习"><a href="#演习" class="headerlink" title="演习"></a>演习</h2><p><img src="/images/%E6%BC%94%E4%B9%A01%E6%8B%93%E6%89%91%E5%9B%BE.jpg"><br>条件：</p><blockquote><ul><li>拓扑图如上所示</li></ul></blockquote><ul><li>建立单臂路由实现三个PC之间的相互通信</li></ul><p>Router设定</p><div class="hljs code-wrapper"><pre><code class="hljs C">Router(config)<span class="hljs-meta">#interface fastethernet 0.1</span>Router(config-subif)<span class="hljs-meta">#encapsulation dot1q 1</span>Router(config-subif)<span class="hljs-meta">#ip address 172.16.1.254 255.255.255.0</span>Router(config-subif)<span class="hljs-meta">#exit</span>Router(config)<span class="hljs-meta">#interface fastethernet 0.10</span>Router(config-subif)<span class="hljs-meta">#encapsulation dot1q 10</span>Router(config-subif)<span class="hljs-meta">#ip address 172.16.10.254 255.255.255.0</span>Router(config-subif)<span class="hljs-meta">#exit</span>Router(config)<span class="hljs-meta">#interface fastethernet 0.20</span>Router(config-subif)<span class="hljs-meta">#encapsulation dot1q 20</span>Router(config-subif)<span class="hljs-meta">#ip address 172.16.20.254 255.255.255.0</span>Router(config-subif)<span class="hljs-meta">#exit</span>Router(config)<span class="hljs-meta">#interface fastethernet 0.99</span>Router(config-subif)<span class="hljs-meta">#encapsulation dot1q 99 native</span>Router(config-subif)<span class="hljs-meta">#exit</span>Router(config)<span class="hljs-meta">#interface fastethernet 0</span>Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#no shutdown</span></code></pre></div><p>switch设定</p><div class="hljs code-wrapper"><pre><code class="hljs C">Switch(config)<span class="hljs-meta">#vlan 10,20,99</span>Switch(config-vlan)<span class="hljs-meta">#exit</span>Switch(config)<span class="hljs-meta">#interface range fastethernet 0/1 - 3</span><span class="hljs-keyword">switch</span>(config-<span class="hljs-keyword">if</span>-range)<span class="hljs-meta">#switchport mode access</span>Switch(config-<span class="hljs-keyword">if</span>-range)<span class="hljs-meta">#interface fastethernet 0/2</span>Switch(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#switchport access vlan 10</span>Switch(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#interface fastethernet 0/3</span>Switch(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#switchport access vlan 20</span>Switch(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#interface fastethernet 0/12</span>Switch(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#switchport trunk encapsulation dot1q</span>Switch(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#switchport mode trunk</span><span class="hljs-comment">//Switch(config-if)#switchport nonegotiate  2950switch已经不需要这一步骤</span>Switch(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#switchport trunk native vlan 99</span>Switch(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#interface vlan 1</span>Switch(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#ip address 172.16.1.100 255.255.255.0</span>Switch(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#no shutdown</span>Switch(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#exit</span>Switch(config)<span class="hljs-meta">#ip default-gateway 172.16.1.254</span>Switch(config)<span class="hljs-meta">#exit</span></code></pre></div><h3 id="单臂路由的验证"><a href="#单臂路由的验证" class="headerlink" title="单臂路由的验证"></a>单臂路由的验证</h3><p>Router</p><div class="hljs code-wrapper"><pre><code class="hljs C">Router<span class="hljs-meta">#show ip interface [brief]</span>Router<span class="hljs-meta">#show ip route</span>Router<span class="hljs-meta">#show vlans</span></code></pre></div><p>Switch</p><div class="hljs code-wrapper"><pre><code class="hljs C">Switch<span class="hljs-meta">#show interfaces trunk</span>Switch<span class="hljs-meta">#show interfaces switchport</span>Switch<span class="hljs-meta">#show vlan [brief]</span>Switch<span class="hljs-meta">#show interfaces vlan <span class="hljs-meta-string">&lt;vlan-id&gt;</span></span>Switch<span class="hljs-meta">#show run</span></code></pre></div><h3 id="演习结果"><a href="#演习结果" class="headerlink" title="演习结果"></a>演习结果</h3><p>switch端结果</p><div class="hljs code-wrapper"><pre><code class="hljs C">Switch<span class="hljs-meta">#show vlan</span>VLAN Name                             Status    Ports---- -------------------------------- --------- -------------------------------<span class="hljs-number">1</span>    <span class="hljs-keyword">default</span>                          active    Fa0/<span class="hljs-number">17</span>, Fa0/<span class="hljs-number">18</span>, Fa0/<span class="hljs-number">19</span>, Fa0/<span class="hljs-number">20</span>                                                Fa0/<span class="hljs-number">21</span>, Fa0/<span class="hljs-number">22</span>, Fa0/<span class="hljs-number">23</span><span class="hljs-number">10</span>   VLAN0010                         active    Fa0/<span class="hljs-number">1</span>, Fa0/<span class="hljs-number">2</span>, Fa0/<span class="hljs-number">4</span>, Fa0/<span class="hljs-number">5</span>                                                Fa0/<span class="hljs-number">6</span>, Fa0/<span class="hljs-number">7</span>, Fa0/<span class="hljs-number">8</span><span class="hljs-number">20</span>   VLAN0020                         active    Fa0/<span class="hljs-number">3</span>, Fa0/<span class="hljs-number">9</span>, Fa0/<span class="hljs-number">10</span>, Fa0/<span class="hljs-number">11</span>                                                Fa0/<span class="hljs-number">12</span>, Fa0/<span class="hljs-number">13</span>, Fa0/<span class="hljs-number">14</span>, Fa0/<span class="hljs-number">15</span>                                                Fa0/<span class="hljs-number">16</span><span class="hljs-number">99</span>   VLAN0099                         active<span class="hljs-number">1002</span> fddi-<span class="hljs-keyword">default</span>                     active<span class="hljs-number">1003</span> token-ring-<span class="hljs-keyword">default</span>               active<span class="hljs-number">1004</span> fddinet-<span class="hljs-keyword">default</span>                  active<span class="hljs-number">1005</span> trnet-<span class="hljs-keyword">default</span>                    activeVLAN Type  SAID       MTU   Parent RingNo BridgeNo Stp  BrdgMode Trans1 Trans2---- ----- ---------- ----- ------ ------ -------- ---- -------- ------ ------<span class="hljs-number">1</span>    enet  <span class="hljs-number">100001</span>     <span class="hljs-number">1500</span>  -      -      -        -    -        <span class="hljs-number">0</span>      <span class="hljs-number">0</span><span class="hljs-number">10</span>   enet  <span class="hljs-number">100010</span>     <span class="hljs-number">1500</span>  -      -      -        -    -        <span class="hljs-number">0</span>      <span class="hljs-number">0</span><span class="hljs-number">20</span>   enet  <span class="hljs-number">100020</span>     <span class="hljs-number">1500</span>  -      -      -        -    -        <span class="hljs-number">0</span>      <span class="hljs-number">0</span><span class="hljs-number">99</span>   enet  <span class="hljs-number">100099</span>     <span class="hljs-number">1500</span>  -      -      -        -    -        <span class="hljs-number">0</span>      <span class="hljs-number">0</span><span class="hljs-number">1002</span> fddi  <span class="hljs-number">101002</span>     <span class="hljs-number">1500</span>  -      -      -        -    -        <span class="hljs-number">0</span>      <span class="hljs-number">0</span><span class="hljs-number">1003</span> tr    <span class="hljs-number">101003</span>     <span class="hljs-number">1500</span>  -      -      -        -    -        <span class="hljs-number">0</span>      <span class="hljs-number">0</span><span class="hljs-number">1004</span> fdnet <span class="hljs-number">101004</span>     <span class="hljs-number">1500</span>  -      -      -        ieee -        <span class="hljs-number">0</span>      <span class="hljs-number">0</span><span class="hljs-number">1005</span> trnet <span class="hljs-number">101005</span>     <span class="hljs-number">1500</span>  -      -      -        ibm  -        <span class="hljs-number">0</span>      <span class="hljs-number">0</span>Remote SPAN VLANs------------------------------------------------------------------------------Primary Secondary Type              Ports------- --------- ----------------- ------------------------------------------</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs C">Switch<span class="hljs-meta">#show interface trunk</span>Port        Mode         Encapsulation  Status        Native vlanFa0/<span class="hljs-number">24</span>      on           <span class="hljs-number">802.1</span>q         trunking      <span class="hljs-number">1</span>Port      Vlans allowed on trunkFa0/<span class="hljs-number">24</span>      <span class="hljs-number">1</span><span class="hljs-number">-4094</span>Port        Vlans allowed <span class="hljs-keyword">and</span> active in management domainFa0/<span class="hljs-number">24</span>      <span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">99</span>Port        Vlans in spanning tree forwarding state <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> prunedFa0/<span class="hljs-number">24</span>      <span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">99</span></code></pre></div><p>Router端结果</p><div class="hljs code-wrapper"><pre><code class="hljs C">Router<span class="hljs-meta">#show ip interface brief</span>Interface                  IP-Address      OK? Method Status                Prot                                                                                                             ocolFastEthernet0              unassigned      YES NVRAM  up                    up                                                                                                               FastEthernet0<span class="hljs-number">.1</span>            <span class="hljs-number">172.16</span><span class="hljs-number">.1</span><span class="hljs-number">.254</span>    YES manual up                    up                                                                                                               FastEthernet0<span class="hljs-number">.10</span>           <span class="hljs-number">172.16</span><span class="hljs-number">.10</span><span class="hljs-number">.254</span>   YES manual up                    up                                                                                                               FastEthernet0<span class="hljs-number">.20</span>           <span class="hljs-number">172.16</span><span class="hljs-number">.20</span><span class="hljs-number">.254</span>   YES manual up                    up                                                                                                               FastEthernet0<span class="hljs-number">.99</span>           unassigned      YES unset  up                    up                                                                                                               FastEthernet1              unassigned      YES NVRAM  up                    down                                                                                                             BRI0                       unassigned      YES NVRAM  administratively down down                                                                                                             BRI0:<span class="hljs-number">1</span>                     unassigned      YES unset  administratively down down                                                                                                             BRI0:<span class="hljs-number">2</span>                     unassigned      YES unset  administratively down down                                                                                                             FastEthernet2              unassigned      YES unset  up                    down                                                                                                             FastEthernet3              unassigned      YES unset  up                    down</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs C">Router<span class="hljs-meta">#show ip route</span>Codes: C - connected, S - <span class="hljs-keyword">static</span>, R - RIP, M - mobile, B - BGP       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area       N1 - OSPF NSSA external type <span class="hljs-number">1</span>, N2 - OSPF NSSA external type <span class="hljs-number">2</span>       E1 - OSPF external type <span class="hljs-number">1</span>, E2 - OSPF external type <span class="hljs-number">2</span>       i - IS-IS, su - IS-IS summary, L1 - IS-IS level<span class="hljs-number">-1</span>, L2 - IS-IS level<span class="hljs-number">-2</span>       ia - IS-IS inter area, * - candidate <span class="hljs-keyword">default</span>, U - per-user <span class="hljs-keyword">static</span> route       o - ODR, P - periodic downloaded <span class="hljs-keyword">static</span> routeGateway of last resort is <span class="hljs-keyword">not</span> <span class="hljs-built_in">set</span>     <span class="hljs-number">172.16</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span> is subnetted, <span class="hljs-number">3</span> subnetsC       <span class="hljs-number">172.16</span><span class="hljs-number">.20</span><span class="hljs-number">.0</span> is directly connected, FastEthernet0<span class="hljs-number">.20</span>C       <span class="hljs-number">172.16</span><span class="hljs-number">.10</span><span class="hljs-number">.0</span> is directly connected, FastEthernet0<span class="hljs-number">.10</span>C       <span class="hljs-number">172.16</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> is directly connected, FastEthernet0<span class="hljs-number">.1</span></code></pre></div><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>做完这个实验才理解了为什么单臂路由为什么在network里如此重要，也理解了为什么前两节课先生要那么大力气讲access和trunk的作用，通过路由器的虚拟网口，可以变相地将一台路由器当作多台使用（毕竟路由器那么贵），switch也变相承担了路由器的部分功能（switch相对便宜），但是虚拟网口是否能无限扩容并且实际体验是否能跟物理接续体验一致也是以后值得研究的课题。</p>]]></content>
    
    
    <categories>
      
      <category>network实践笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>cisco</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【network实践】标准ACL</title>
    <link href="/2018/12/04/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A0%87%E5%87%86ACL/"/>
    <url>/2018/12/04/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A0%87%E5%87%86ACL/</url>
    
    <content type="html"><![CDATA[<p>ACL(Access Control List)是进行网络通信识别控制中记录控制条件的一个表，在Router的interface中应用，与许可条件一致的话就可以通过，除此以外全部拒绝通信。  </p><a id="more"></a><p>标准acl list的号码可以是1〜99和1300〜1999，扩张acl list号码为100〜199和2000〜2699。</p><h2 id="演习"><a href="#演习" class="headerlink" title="演习"></a>演习</h2><p><img src="/images/%E6%A0%87%E5%87%86ACL.jpg"></p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><blockquote><ul><li>组成如图所示的网络并相互ping通</li></ul></blockquote><ul><li>192.168.1.0所属的PC能够和192.168.2.1通信</li><li>但是192.168.1.1拒绝通信</li></ul><p>配置路由器</p><div class="hljs code-wrapper"><pre><code class="hljs C">Router(config)<span class="hljs-meta">#interface fastethernet 0</span>Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#ip address 192.168.1.254 255.255.255.0</span>Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#no shutdown</span>Router(config)<span class="hljs-meta">#interface fastethernet 1</span>Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#ip address 192.168.2.254 255.255.255.0</span>Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#no shutdown</span>Router<span class="hljs-meta">#show interface 确认端口是否设置成功</span></code></pre></div><p>配置ACL</p><div class="hljs code-wrapper"><pre><code class="hljs C">Router(config)<span class="hljs-meta">#access-list 1 deny host 192.168.1.1</span>Router(config)<span class="hljs-meta">#access-list 1 permit any</span>Router(config)<span class="hljs-meta">#interface fastethernet 0</span>Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#ip access-group 1 in</span>Router<span class="hljs-meta">#show access-lists  确认ACL创建成功</span></code></pre></div><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><blockquote><ul><li>PC B,PC C,PC D之间可以相互ping</li></ul></blockquote><ul><li>PC A和PC D不能ping成功</li></ul><p>如果选择Fa 1端口配置ACL的话，就修改成如下代码</p><div class="hljs code-wrapper"><pre><code class="hljs C">Router(config)<span class="hljs-meta">#interface fastethernet 1</span>Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#ip access-group 1 out</span>Router<span class="hljs-meta">#show access-lists  确认ACL创建成功</span></code></pre></div><p>如果不需要这个ACL的话</p><div class="hljs code-wrapper"><pre><code class="hljs C">Router(config)<span class="hljs-meta">#no access-list 1</span></code></pre></div><p>就可以将ACL删去.</p><p>ACL的对照顺序是自上向下并且默认是deny的，如果将实验中ACL的两行互换在本演习中理论上没有影响，但是具体实验并没有实施，“顺序因素对ACL的影响”是以后可以考虑的问题点之一。</p>]]></content>
    
    
    <categories>
      
      <category>network实践笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>cisco</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【network实践】扩展ACL(二)</title>
    <link href="/2018/12/04/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%89%A9%E5%B1%95ACL%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2018/12/04/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%89%A9%E5%B1%95ACL%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="演习2"><a href="#演习2" class="headerlink" title="演习2"></a>演习2</h2><p> 与标准ACL不同，扩展ACL可以进行对送信元IP地址、宛先IP地址、プロトコル、送信元ポート、宛先ポート的控制来进行针对性的访问控制。  </p><a id="more"></a><p><img src="/images/%E6%BC%94%E4%B9%A01%E6%8B%93%E6%89%91%E5%9B%BE.jpg">  </p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol><li>网络拓扑图如图所示，首先PC之间互相ping通。  </li><li>从NW_A（192.168.1.0）到NW_B（192.168.2.0）的telnet拒绝，其他的数据包都可正常传输。</li></ol><p>配置路由器</p><div class="hljs code-wrapper"><pre><code class="hljs C">Router(config)<span class="hljs-meta">#interface fastethernet 0</span>Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#ip address 192.168.1.254 255.255.255.0</span>Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#no shutdown</span>Router(config)<span class="hljs-meta">#interface fastethernet 1</span>Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#ip address 192.168.2.254 255.255.255.0</span>Router(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#no shutdown</span>Router<span class="hljs-meta">#show interface   确认端口是否配置成功</span></code></pre></div><p>配置ACL </p><div class="hljs code-wrapper"><pre><code class="hljs C">Router(config)<span class="hljs-meta">#access-list 100 deny tcp host 192.168.1.1 host 192.168.2.1 eq 23  </span>Router(config)<span class="hljs-meta">#access-list 100 permit ip any any</span>Router(config)<span class="hljs-meta">#show access-lists 确认ACL是否建立成功</span>Router(config)<span class="hljs-meta">#interface fastethernet 0</span>Router(config)<span class="hljs-meta">#ip access-group 100 in</span></code></pre></div><p>配置switch</p><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">switch</span>(config)<span class="hljs-meta">#interface vlan 1</span><span class="hljs-keyword">switch</span>(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#ip address 192.168.1.100 255.255.255.0</span><span class="hljs-keyword">switch</span>(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#no shutdown</span><span class="hljs-keyword">switch</span>(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta">#exit</span><span class="hljs-keyword">switch</span>(config)<span class="hljs-meta">#ip default-gateway 192.168.1.254</span></code></pre></div><p>switch有两台，根据上述代码可以配置另一台  </p><p>配置router密码  </p><div class="hljs code-wrapper"><pre><code class="hljs C">Router(config)<span class="hljs-meta">#<span class="hljs-meta-keyword">line</span> vty 0 4</span>Router(config-line)<span class="hljs-meta">#password cisco</span>Router(config-line)<span class="hljs-meta">#login</span>Router(config-line)<span class="hljs-meta">#end</span>Router<span class="hljs-meta">#show run 确认router密码是否配置成功</span></code></pre></div><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>最终结果为PCA无法telnet到PCB（显示访问拒绝），但是PCB可以telnet到PCA，电脑之间的互相ping正常。</p>]]></content>
    
    
    <categories>
      
      <category>network实践笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>cisco</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【network实践】扩展ACL(一)</title>
    <link href="/2018/12/03/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%89%A9%E5%B1%95ACL%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2018/12/03/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%89%A9%E5%B1%95ACL%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p> 与标准ACL不同，扩展ACL可以进行对送信元IP地址、宛先IP地址、プロトコル、送信元ポート、宛先ポート的控制来进行针对性的访问控制。</p><a id="more"></a><h2 id="演习1"><a href="#演习1" class="headerlink" title="演习1"></a>演习1</h2><p><img src="/images/%E6%BC%94%E4%B9%A01%E6%8B%93%E6%89%91%E5%9B%BE.jpg">  </p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol><li>整个网络要能互相ping通  </li><li>设置番号为100的扩展ACL，从PC A1到PC B1的数据包全部拒绝，其余都许可通信。</li></ol><p>首先配置路由器让其互相ping通  </p><div class="hljs code-wrapper"><pre><code class="hljs C">Router(config)<span class="hljs-meta">#interface fastethernet 0</span>Router(config)<span class="hljs-meta">#ip address 192.168.1.254 255.255.255.0</span>Router(config)<span class="hljs-meta">#no shutdown</span>Router(config)<span class="hljs-meta">#interface fastethernet 1</span>Router(config)<span class="hljs-meta">#ip address 192.168.2.254 255.255.255.0</span>Router(config)<span class="hljs-meta">#no shutdown</span>Router<span class="hljs-meta">#show interface   确认端口是否配置成功</span></code></pre></div><p>配置ACL</p><div class="hljs code-wrapper"><pre><code class="hljs C">Router(config)<span class="hljs-meta">#access-list 100 deny ip host 192.168.1.1 host 192.168.2.1</span>Router(config)<span class="hljs-meta">#access-list 100 permit ip any any</span>Router(config)<span class="hljs-meta">#show access-lists 确认ACL是否建立成功</span>Router(config)<span class="hljs-meta">#interface fastethernet 0</span>Router(config)<span class="hljs-meta">#ip access-group 100 in</span></code></pre></div><p>如果想设置Fa 1端口，就用</p><div class="hljs code-wrapper"><pre><code class="hljs C">Router(config)<span class="hljs-meta">#interface fastethernet 1  </span>Router(config)<span class="hljs-meta">#ip access-group 100 out</span></code></pre></div><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>最后检查结果时，会出现PCA1到PCB1到达不能，PCB1到PCA1出现timeout，这是正常结果，因为tcp/ip的三次握手中，当PCA1到PCB1通路阻断时，PCA1不能回应PCB1发出的“问候”，从而出现timeout。  </p>]]></content>
    
    
    <categories>
      
      <category>network实践笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>cisco</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
