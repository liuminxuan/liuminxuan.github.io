<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【剑指offer】21. 调整数组顺序使奇数位于偶数前面</title>
    <link href="/2020/09/04/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
    <url>/2020/09/04/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer刷题笔记：21-调整数组顺序使奇数位于偶数前面"><a href="#剑指offer刷题笔记：21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指offer刷题笔记：21. 调整数组顺序使奇数位于偶数前面"></a>剑指offer刷题笔记：21. 调整数组顺序使奇数位于偶数前面</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class="language-none"><code class="language-none">输入：nums &#x3D; [1,2,3,4]输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。</code></pre><h2 id="解题思路1-头尾指针"><a href="#解题思路1-头尾指针" class="headerlink" title="解题思路1 头尾指针"></a>解题思路1 头尾指针</h2><p>记录这题是因为这是最近leetcode第一道没有出现错误一气呵成的题目，算是一个小小的里程碑吧。虽然很简单，但是给了我信心哈哈。<br>算法很简单，首先创建一个新数组，然后遍历原数组，遇到奇数放到头上，遇到偶数放到尾巴上。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public int[] exchange(int[] nums) &#123;        &#x2F;&#x2F; new一个新数组        int[] res &#x3D; new int[nums.length];        &#x2F;&#x2F; 确定新数组的头和尾的位置        int h &#x3D; 0;        int t &#x3D; nums.length - 1;        &#x2F;&#x2F; 遍历nums，如果为奇数则放入新数组头的位置，否则放入新数组尾巴的位置        for(int i &#x3D; 0; i &lt; nums.length; i++)&#123;            if(nums[i] % 2 &#x3D;&#x3D; 1)&#123;                res[h] &#x3D; nums[i];                h++;            &#125;else&#123;                res[t] &#x3D; nums[i];                t--;            &#125;        &#125;        return res;    &#125;&#125;</code></pre><h2 id="解题思路2-原数组上交换"><a href="#解题思路2-原数组上交换" class="headerlink" title="解题思路2 原数组上交换"></a>解题思路2 原数组上交换</h2><p>因为解题思路1的内存消耗较大，所以想到在原数组上互换。<br>结果内存消耗从49.4MB变为47.6MB，超越人数从2%提升到90%。<br>但是执行用时从超越99%的2ms变为超越34.3%的3ms。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public int[] exchange(int[] nums) &#123;        int head &#x3D; 0;        int tail &#x3D; nums.length - 1;        &#x2F;&#x2F; if-else的顺序十分巧妙        &#x2F;&#x2F; 先判断头尾是否符合要求，如果前两个if都走完了说明两个都不符合要求，则互换        while(head &lt;&#x3D; tail)&#123;            if(nums[head] % 2 &#x3D;&#x3D; 1)&#123;                head++;            &#125;else if(nums[tail] % 2 &#x3D;&#x3D; 0)&#123;                tail--;            &#125;else&#123;                int tmp &#x3D; nums[head];                nums[head] &#x3D; nums[tail];                nums[tail] &#x3D; tmp;                head++;                tail--;            &#125;        &#125;        return nums;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>剑指offer刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】18. 删除链表的节点</title>
    <link href="/2020/09/03/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2020/09/03/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。<br><strong>注意</strong>：此题对比原题有改动</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><pre class="language-none"><code class="language-none">输入: head &#x3D; [4,5,1,9], val &#x3D; 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</code></pre><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><pre class="language-none"><code class="language-none">输入: head &#x3D; [4,5,1,9], val &#x3D; 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</code></pre><h2 id="解题思路1-双指针"><a href="#解题思路1-双指针" class="headerlink" title="解题思路1 双指针"></a>解题思路1 双指针</h2><p>Leetcode上大多数关于链表的题目都可以用双指针来解决，此题也不例外。<br>前指针记录前一个节点，现指针记录现在的节点，这样当现指针找到对应节点时直接让前指针指向现指针之后的节点。<br>注意当第一个节点为要找的节点时直接返回第二个节点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public ListNode deleteNode(ListNode head, int val) &#123;        if(head.val &#x3D;&#x3D; val) return head.next; &#x2F;&#x2F; 如果头节点的值等于val，直接返回头节点的下一个        ListNode dummy &#x3D; new ListNode(-1); &#x2F;&#x2F; 取出头节点，最后好直接返回        dummy.next &#x3D; head;        &#x2F;&#x2F; 双指针法，俩指针一前一后        ListNode pre &#x3D; head;        ListNode cur &#x3D; head.next;        while(cur !&#x3D; null)&#123;            if(cur.val &#x3D;&#x3D; val)&#123;                pre.next &#x3D; cur.next;                break;            &#125;            cur &#x3D; cur.next;            pre &#x3D; pre.next;        &#125;        return dummy.next;    &#125;&#125;</code></pre><h2 id="解题思路2-单指针"><a href="#解题思路2-单指针" class="headerlink" title="解题思路2 单指针"></a>解题思路2 单指针</h2><p>因为此题如果使用双指针，两个指针永远是一前一后，所以可以用head和head.next来代替双指针。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public ListNode deleteNode(ListNode head, int val) &#123;        if(head.val &#x3D;&#x3D; val) return head.next; &#x2F;&#x2F; 如果头节点的值等于val，直接返回头节点的下一个        ListNode dummy &#x3D; new ListNode(-1); &#x2F;&#x2F; 取出头节点，最后好直接返回        dummy.next &#x3D; head;        while(head.next !&#x3D; null)&#123;            if(head.next.val &#x3D;&#x3D; val)&#123;                head.next &#x3D; head.next.next;                break;            &#125;            head &#x3D; head.next;        &#125;        return dummy.next;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>剑指offer刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】39. 数组中出现次数超过一半的数字</title>
    <link href="/2020/09/02/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B039-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/09/02/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B039-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39. 数组中出现次数超过一半的数字"></a>39. 数组中出现次数超过一半的数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class="language-none"><code class="language-none">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2</code></pre><h2 id="解题思路1-排序"><a href="#解题思路1-排序" class="headerlink" title="解题思路1 排序"></a>解题思路1 排序</h2><p>因为需要的数字出现次数多于一半，那么排序后必定在中间。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public int majorityElement(int[] nums) &#123;        Arrays.sort(nums);        return nums[nums.length&#x2F;2];    &#125;&#125;</code></pre><h2 id="解题思路2-HashMap"><a href="#解题思路2-HashMap" class="headerlink" title="解题思路2 HashMap"></a>解题思路2 HashMap</h2><p>数数然后查找这种问题一定会想到HashMap，虽然执行效率不高，但是也算能出结果</p><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public int majorityElement(int[] nums) &#123;        if(nums.length &#x3D;&#x3D; 1) return nums[0];        &#x2F;&#x2F; 移位运算高级写法        &#x2F;&#x2F; int half &#x3D; nums.length &gt;&gt; 1;        int half &#x3D; nums.length &#x2F; 2;        HashMap&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();        for(int i &#x3D; 0; i &lt; nums.length; i++)&#123;            &#x2F;&#x2F; 如果HashMap包含数组中的值，则先判断数量是否过半，如无过半，则数量加1            &#x2F;&#x2F; 不包含则创建一个新的Key和值为1的count            if(map.containsKey(nums[i]))&#123;                int count &#x3D; map.get(nums[i]);                if(++count &gt; half)&#123;                    return nums[i];                &#125;                &#x2F;&#x2F; map.remove(nums[i]);                map.put(nums[i], count);            &#125;else&#123;                map.put(nums[i], 1);            &#125;        &#125;        return -1;    &#125;&#125;</code></pre><h2 id="解题思路3-摩尔投票法"><a href="#解题思路3-摩尔投票法" class="headerlink" title="解题思路3 摩尔投票法"></a>解题思路3 摩尔投票法</h2><p>思想是将不同的数字互相消解，那最后余下的数字就是相同的数字。</p><blockquote><p>用target记录上一次访问的值，count表明当前值出现的次数，如果下一个值和当前值相同那么count++；如果不同count–，减到0的时候就要更换新的target值了，因为如果存在超过数组长度一半的值，那么最后target一定会是该值。可以这样理解，count的自加和自减就是在描述一种抵消关系，由于超过一半的出现次数，导致最后的target一定会是该值。（这种方法的时间复杂度自然会小些）</p></blockquote><h3 id="代码3"><a href="#代码3" class="headerlink" title="代码3"></a>代码3</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public int majorityElement(int[] nums) &#123;        int target &#x3D; nums[0]; &#x2F;&#x2F; 初始化为数组的第一个元素，接下来用于记录上一次访问的值        int count &#x3D; 1; &#x2F;&#x2F; 用于记录出现次数        for(int i &#x3D; 0; i &lt; nums.length; i++)&#123;            if(nums[i] &#x3D;&#x3D; target)&#123;                count++;            &#125;else&#123;                count--;            &#125;            &#x2F;&#x2F; 当count&#x3D;0时，更换target的值为当前访问的数组元素的值，次数设为1            if(count &#x3D;&#x3D; 0)&#123;                target &#x3D; nums[i];                count &#x3D; 1;            &#125;        &#125;        return target;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>剑指offer刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】内部类</title>
    <link href="/2020/09/01/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>/2020/09/01/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="关于内部类"><a href="#关于内部类" class="headerlink" title="关于内部类"></a>关于内部类</h1><blockquote><p>内部类(inner class) : 定义在另一个类重的类</p></blockquote><p>为什么需要内部类？</p><ul><li>内部类方法可以访问该类定义所在作用域中的数据，包括被 private 修饰的私有数据</li><li>内部类可以对同一包中的其他类隐藏起来</li><li>内部类可以一定程度修复 java 单继承的缺陷</li><li>当我们想要定义一个回调函数却不想写大量代码的时候我们可以选择使用匿名内部类来实现</li></ul><h1 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h1><p>内部类可以分为：静态内部类（嵌套类）和非静态内部类。非静态内部类又可以分为：成员内部类、方法内部类、匿名内部类。</p><h2 id="静态内部类和非静态内部类的区别"><a href="#静态内部类和非静态内部类的区别" class="headerlink" title="静态内部类和非静态内部类的区别"></a>静态内部类和非静态内部类的区别</h2><ol><li>静态内部类可以有静态成员，而非静态内部类则不能有静态成员。</li><li>静态内部类可以访问外部类的静态变量，而不可访问外部类的非静态变量；</li><li>非静态内部类的非静态成员可以访问外部类的非静态变量。</li><li>静态内部类的创建不依赖于外部类，而非静态内部类必须依赖于外部类的创建而创建。</li></ol><p><strong>静态内部类</strong></p><pre class="language-Java" data-language="Java"><code class="language-Java">public class ClassOuter &#123;    private int noStaticInt &#x3D; 1;    private static int STATIC_INT &#x3D; 2;    public void fun() &#123;        System.out.println(&quot;外部类方法&quot;);    &#125;    public class InnerClass &#123;        &#x2F;&#x2F;static int num &#x3D; 1; 此时编辑器会报错 非静态内部类则不能有静态成员        public void fun()&#123;            &#x2F;&#x2F;非静态内部类的非静态成员可以访问外部类的非静态变量。            System.out.println(STATIC_INT);            System.out.println(noStaticInt);        &#125;    &#125;    public static class StaticInnerClass &#123;        static int NUM &#x3D; 1;&#x2F;&#x2F;静态内部类可以有静态成员        public void fun()&#123;            System.out.println(STATIC_INT);            &#x2F;&#x2F;System.out.println(noStaticInt); 此时编辑器会报 不可访问外部类的非静态变量错        &#125;    &#125;&#125;public class TestInnerClass &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;非静态内部类 创建方式1        ClassOuter.InnerClass innerClass &#x3D; new ClassOuter().new InnerClass();        &#x2F;&#x2F;非静态内部类 创建方式2        ClassOuter outer &#x3D; new ClassOuter();        ClassOuter.InnerClass inner &#x3D; outer.new InnerClass();        &#x2F;&#x2F;静态内部类的创建方式        ClassOuter.StaticInnerClass staticInnerClass &#x3D; new ClassOuter.StaticInnerClass();    &#125;&#125;</code></pre><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。<br>在成员内部类中要注意两点：</p><ol><li>成员内部类中不能存在任何static的变量和方法，成员内部类里不能有静态内部类</li><li>成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类</li></ol><pre class="language-Java" data-language="Java"><code class="language-Java">public class OuterClass &#123;    private String str;        public void outerDisplay()&#123;        System.out.println(&quot;outerClass...&quot;);    &#125;        public class InnerClass&#123;        public void innerDisplay()&#123;            &#x2F;&#x2F;使用外围内的属性            str &#x3D; &quot;inner...&quot;;            System.out.println(str);            &#x2F;&#x2F;使用外围内的方法            outerDisplay();        &#125;    &#125;        &#x2F;*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 *&#x2F;    public InnerClass getInnerClass()&#123;        return new InnerClass();    &#125;        public static void main(String[] args) &#123;        OuterClass outer &#x3D; new OuterClass();        OuterClass.InnerClass inner &#x3D; outer.getInnerClass();        inner.innerDisplay();    &#125;&#125;--------------------innner...outerClass...</code></pre><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>定义在方法或作用域中的内部类，出了该方法，类就会失效。<br><strong>定义在方法中</strong></p><pre class="language-Java" data-language="Java"><code class="language-Java">public class Parcel5 &#123;    public Destionation destionation(String str)&#123;        class PDestionation implements Destionation&#123;            private String label;            private PDestionation(String whereTo)&#123;                label &#x3D; whereTo;            &#125;            public String readLabel()&#123;                return label;            &#125;        &#125;        return new PDestionation(str);    &#125;        public static void main(String[] args) &#123;        Parcel5 parcel5 &#x3D; new Parcel5();        Destionation d &#x3D; parcel5.destionation(&quot;chenssy&quot;);    &#125;&#125;</code></pre><p><strong>定义在作用域中</strong></p><pre class="language-Java" data-language="Java"><code class="language-Java">public class Parcel6 &#123;    private void internalTracking(boolean b)&#123;        if(b)&#123;            class TrackingSlip&#123;                private String id;                TrackingSlip(String s) &#123;                    id &#x3D; s;                &#125;                String getSlip()&#123;                    return id;                &#125;            &#125;            TrackingSlip ts &#x3D; new TrackingSlip(&quot;chenssy&quot;);            String string &#x3D; ts.getSlip();        &#125;    &#125;        public void track()&#123;        internalTracking(true);    &#125;        public static void main(String[] args) &#123;        Parcel6 parcel6 &#x3D; new Parcel6();        parcel6.track();    &#125;&#125;</code></pre><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名类实现接口和抽象类定义的抽象方法，快速创建一个抽象类的实例，可以出现在任何有代码的地方。</p><ol><li>匿名内部类是没有访问修饰符的。</li><li>匿名内部类必须继承一个抽象类或者实现一个接口</li><li>匿名内部类中不能存在任何静态成员或方法</li><li>匿名内部类是没有构造方法的，因为它没有类名。</li><li><strong>与局部内部相同匿名内部类也可以引用局部变量。此变量也必须声明为 final</strong></li></ol><pre class="language-Java" data-language="Java"><code class="language-Java">public class OuterClass &#123;    public InnerClass getInnerClass(final int num,String str2)&#123;        return new InnerClass()&#123;            int number &#x3D; num + 3;            public int getNumber()&#123;                return number;            &#125;        &#125;;        &#x2F;* 注意：分号不能省 *&#x2F;    &#125;        public static void main(String[] args) &#123;        OuterClass out &#x3D; new OuterClass();        InnerClass inner &#x3D; out.getInnerClass(2, &quot;chenssy&quot;);        System.out.println(inner.getNumber());    &#125;&#125;interface InnerClass &#123;    int getNumber();&#125;----------------Output:5</code></pre><h3 id="为什么局部变量需要final修饰呢"><a href="#为什么局部变量需要final修饰呢" class="headerlink" title="为什么局部变量需要final修饰呢"></a>为什么局部变量需要final修饰呢</h3><p>原因是：因为局部变量和匿名内部类的生命周期不同。<br>匿名内部类是创建后是存储在堆中的，而方法中的局部变量是存储在Java栈中，当方法执行完毕后，就进行退栈，同时局部变量也会消失。那么此时匿名内部类还有可能在堆中存储着，那么匿名内部类要到哪里去找这个局部变量呢？<br>为了解决这个问题编译器为自动地帮我们在匿名内部类中创建了一个局部变量的备份，也就是说即使方法执结束，匿名内部类中还有一个备份，自然就不怕找不到了。<br>但是问题又来了。如果局部变量中的a不停的在变化。那么岂不是也要让备份的a变量无时无刻的变化。为了保持局部变量与匿名内部类中备份域保持一致。编译器不得不规定死这些局部域必须是常量，一旦赋值不能再发生变化了。所以为什么匿名内部类应用外部方法的域必须是常量域的原因所在了。</p><p><strong>特别注意：在Java8中已经去掉要对final的修饰限制，但其实只要在匿名内部类使用了，该变量还是会自动变为final类型（只能使用，不能赋值）。</strong></p><h1 id="内部类会引起的问题"><a href="#内部类会引起的问题" class="headerlink" title="内部类会引起的问题"></a>内部类会引起的问题</h1><ol><li>如果一个匿名内部类没有被任何引用持有，那么匿名内部类对象用完就有机会被回收。</li><li>如果内部类仅仅只是在外部类中被引用，当外部类的不再被引用时，外部类和内部类就可以都被GC回收。</li><li>如果当内部类的引用被外部类以外的其他类引用时，就会造成内部类和外部类无法被GC回收的情况，即使外部类没有被引用，因为内部类持有指向外部类的引用）。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><ul><li><a href="https://juejin.im/post/6844903566293860366">https://juejin.im/post/6844903566293860366</a></li><li><a href="https://www.cnblogs.com/chenssy/p/3388487.html">https://www.cnblogs.com/chenssy/p/3388487.html</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】57. 和为s的两个数字</title>
    <link href="/2020/09/01/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A57/"/>
    <url>/2020/09/01/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A57/</url>
    
    <content type="html"><![CDATA[<h1 id="57-和为s的两个数字"><a href="#57-和为s的两个数字" class="headerlink" title="57. 和为s的两个数字"></a>57. 和为s的两个数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><pre class="language-none"><code class="language-none">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[2,7] 或者 [7,2]</code></pre><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><pre class="language-none"><code class="language-none">输入：nums &#x3D; [10,26,30,31,47,60], target &#x3D; 40输出：[10,30] 或者 [30,10]</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>看似简单，因为是升序数组，所以一开始用暴力求解，代码如下：</p><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        int s &#x3D; target;        for(int i &#x3D; 0; i &lt; nums.length - 1; i++)&#123;            for(int j &#x3D; i + 1; j &lt; nums.length; j++)&#123;                if(nums[i] + nums[j] &lt; s)&#123;                    continue;                &#125;else if(nums[i] + nums[j] &gt; s)&#123;                    break;                &#125;else&#123;                    int[] res &#x3D; new int[2];                    res[0] &#x3D; nums[i];                    res[1] &#x3D; nums[j];                    return res;                &#125;            &#125;        &#125;        return new int[0];    &#125;&#125;</code></pre><p>结果超时了，转用HashMap求解。<br>首先当目标数组为空或只有一个值的时候，返回空。然后创建HashMap，遍历数组，将值放入HashMap，如果其中两个值相加可以得到目标值，则返回这两个值的结果。<br>遍历完依旧没有找到目标值，则返回空。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        &#x2F;&#x2F; 当数组为空或只有一个元素的时候，返回空        if(nums.length &lt; 2) return new int[0];        &#x2F;&#x2F; 创建HashMap        HashMap&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();        &#x2F;&#x2F; 遍历数组，如果找到一个值可以与target - nums[i]对应，则返回结果        &#x2F;&#x2F; 如果找不到对应，则把此值放入HashMap        &#x2F;&#x2F; 遍历完成后如果没有返回结果则返回空        for(int i &#x3D; 0; i &lt; nums.length; i++)&#123;            int cur &#x3D; target - nums[i];            if(map.containsKey(cur))&#123;                return new int[] &#123;cur, nums[i]&#125;;            &#125;            map.put(nums[i], i);        &#125;        return new int[0];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>剑指offer刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】接口</title>
    <link href="/2020/08/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%8E%A5%E5%8F%A3/"/>
    <url>/2020/08/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="关于接口"><a href="#关于接口" class="headerlink" title="关于接口"></a>关于接口</h2><p>接口是Java语言中的一个抽象类，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式来继承接口的抽象方法。<br><strong>接口不是类</strong>，编写接口的方式和类很相似，但是他们属于不同的概念。类描述对象的属性和方法，接口则包含类要实现的方法。<br><strong>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</strong><br>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><h3 id="接口与类的相似点"><a href="#接口与类的相似点" class="headerlink" title="接口与类的相似点"></a>接口与类的相似点</h3><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><h3 id="接口与类的区别"><a href="#接口与类的区别" class="headerlink" title="接口与类的区别"></a>接口与类的区别</h3><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口<strong>不能包含成员变量</strong>，除了 static 和 final 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul><h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><ul><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li></ul><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><ol><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</li><li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ol><h2 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h2><p>Interface关键字用来声明一个接口。下面是接口声明的一个简单实例。</p><pre class="language-Java" data-language="Java"><code class="language-Java">&#x2F;* 文件名 : Animal.java *&#x2F;interface Animal &#123;   public void eat();   public void travel();&#125;</code></pre><p>接口有以下特性：</p><ul><li>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。</li><li>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。</li><li>接口中的方法都是公有的。</li></ul><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。<br>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。<br>实例：</p><pre class="language-Java" data-language="Java"><code class="language-Java">&#x2F;* 文件名 : MammalInt.java *&#x2F;public class MammalInt implements Animal&#123;    public void eat()&#123;      System.out.println(&quot;Mammal eats&quot;);   &#125;    public void travel()&#123;      System.out.println(&quot;Mammal travels&quot;);   &#125;     public int noOfLegs()&#123;      return 0;   &#125;    public static void main(String args[])&#123;      MammalInt m &#x3D; new MammalInt();      m.eat();      m.travel();   &#125;&#125;</code></pre><p>以上实例编译运行结果如下:</p><pre class="language-none"><code class="language-none">Mammal eatsMammal travels</code></pre><p>重写接口中声明的方法时，需要注意以下规则：</p><ul><li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li><li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li><li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。<br>在实现接口的时候，也要注意一些规则：</li><li>一个类可以同时实现多个接口。</li><li>一个类只能继承一个类，但是能实现多个接口。</li><li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li></ul><h2 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h2><p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。<br>下面的Sports接口被Hockey和Football接口继承：</p><pre class="language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 文件名: Sports.javapublic interface Sports&#123;   public void setHomeTeam(String name);   public void setVisitingTeam(String name);&#125; &#x2F;&#x2F; 文件名: Football.javapublic interface Football extends Sports&#123;   public void homeTeamScored(int points);   public void visitingTeamScored(int points);   public void endOfQuarter(int quarter);&#125; &#x2F;&#x2F; 文件名: Hockey.javapublic interface Hockey extends Sports&#123;   public void homeGoalScored();   public void visitingGoalScored();   public void endOfPeriod(int period);   public void overtimePeriod(int ot);&#125;</code></pre><p>Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。<br>相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。</p><h2 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h2><p>在Java中，类的多继承是不合法，但接口允许多继承。<br>在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：</p><pre class="language-Java" data-language="Java"><code class="language-Java">public interface Hockey extends Sports, Event</code></pre><p>以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法</p><h2 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h2><p>最常用的继承接口是没有包含任何方法的接口。<br>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。<br>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。<br>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p><pre class="language-Java" data-language="Java"><code class="language-Java">package java.util;public interface EventListener&#123;&#125;</code></pre><p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p><ul><li><strong>建立一个公共的父接口</strong><br>  正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</li><li><strong>向一个类添加数据类型</strong><br>  这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】抽象类和抽象方法</title>
    <link href="/2020/08/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/"/>
    <url>/2020/08/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>Java是面向对象的语言，通过类来描述对象，但是如果一个类中没有足够的信息来描述对象，那么这个类就是抽象类。<br>抽象类<strong>不能被实例化</strong>,但是其他功能照常，成员变量、成员方法和构造方法和普通类一样。<br>由于抽象类不能被实例化，所以抽象类必须被继承后才能使用。<br>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。<br><strong>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</strong></p><h2 id="定义抽象类"><a href="#定义抽象类" class="headerlink" title="定义抽象类"></a>定义抽象类</h2><p>在Java语言中使用abstract class来定义抽象类。如下代码：</p><pre class="language-Java" data-language="Java"><code class="language-Java">&#x2F;* 文件名 : Employee.java *&#x2F;public abstract class Employee&#123;   private String name;   private String address;   private int number;   public Employee(String name, String address, int number)   &#123;      System.out.println(&quot;Constructing an Employee&quot;);      this.name &#x3D; name;      this.address &#x3D; address;      this.number &#x3D; number;   &#125;   public double computePay()   &#123;     System.out.println(&quot;Inside Employee computePay&quot;);     return 0.0;   &#125;   public void mailCheck()   &#123;      System.out.println(&quot;Mailing a check to &quot; + this.name       + &quot; &quot; + this.address);   &#125;   public String toString()   &#123;      return name + &quot; &quot; + address + &quot; &quot; + number;   &#125;   public String getName()   &#123;      return name;   &#125;   public String getAddress()   &#123;      return address;   &#125;   public void setAddress(String newAddress)   &#123;      address &#x3D; newAddress;   &#125;   public int getNumber()   &#123;     return number;   &#125;&#125;</code></pre><p>注意到该 Employee 类没有什么不同，尽管该类是抽象类，但是它仍然有 3 个成员变量，7 个成员方法和 1 个构造方法。 现在如果你尝试如下的例子：</p><pre class="language-Java" data-language="Java"><code class="language-Java">&#x2F;* 文件名 : AbstractDemo.java *&#x2F;public class AbstractDemo&#123;   public static void main(String [] args)   &#123;      &#x2F;* 以下是不允许的，会引发错误 *&#x2F;      Employee e &#x3D; new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43);       System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;);      e.mailCheck();    &#125;&#125;</code></pre><p>当你尝试编译AbstractDemo类时，会产生如下错误：</p><pre class="language-none"><code class="language-none">Employee.java:46: Employee is abstract; cannot be instantiated      Employee e &#x3D; new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43);                   ^1 error</code></pre><h2 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h2><p>我们能通过一般的方法继承Employee类：</p><pre class="language-Java" data-language="Java"><code class="language-Java">&#x2F;* 文件名 : Salary.java *&#x2F;public class Salary extends Employee&#123;   private double salary; &#x2F;&#x2F;Annual salary   public Salary(String name, String address, int number, double      salary)   &#123;       super(name, address, number);       setSalary(salary);   &#125;   public void mailCheck()   &#123;       System.out.println(&quot;Within mailCheck of Salary class &quot;);       System.out.println(&quot;Mailing check to &quot; + getName()       + &quot; with salary &quot; + salary);   &#125;   public double getSalary()   &#123;       return salary;   &#125;   public void setSalary(double newSalary)   &#123;       if(newSalary &gt;&#x3D; 0.0)       &#123;          salary &#x3D; newSalary;       &#125;   &#125;   public double computePay()   &#123;      System.out.println(&quot;Computing salary pay for &quot; + getName());      return salary&#x2F;52;   &#125;&#125;</code></pre><p>尽管我们不能实例化一个 Employee 类的对象，但是如果我们实例化一个 Salary 类对象，该对象将从 Employee 类继承 7 个成员方法，且通过该方法可以设置或获取三个成员变量。</p><pre class="language-Java" data-language="Java"><code class="language-Java">&#x2F;* 文件名 : AbstractDemo.java *&#x2F;public class AbstractDemo&#123;   public static void main(String [] args)   &#123;      Salary s &#x3D; new Salary(&quot;Mohd Mohtashim&quot;, &quot;Ambehta, UP&quot;, 3, 3600.00);      Employee e &#x3D; new Salary(&quot;John Adams&quot;, &quot;Boston, MA&quot;, 2, 2400.00);       System.out.println(&quot;Call mailCheck using Salary reference --&quot;);      s.mailCheck();       System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;);      e.mailCheck();    &#125;&#125;</code></pre><p>以上程序编译运行结果如下：</p><pre class="language-none"><code class="language-none">Constructing an EmployeeConstructing an EmployeeCall mailCheck using  Salary reference --Within mailCheck of Salary classMailing check to Mohd Mohtashim with salary 3600.0Call mailCheck using Employee reference--Within mailCheck of Salary classMailing check to John Adams with salary 2400.</code></pre><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。<br>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。<br>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><pre class="language-Java" data-language="Java"><code class="language-Java">public abstract class Employee&#123;   private String name;   private String address;   private int number;      public abstract double computePay();      &#x2F;&#x2F;其余代码&#125;</code></pre><p>声明抽象方法会造成以下两个结果：</p><ul><li>如果一个类包含抽象方法，那么该类必须是抽象类。</li><li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。<br>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。<br>如果Salary类继承了Employee类，那么它必须实现computePay()方法：<pre class="language-Java" data-language="Java"><code class="language-Java">&#x2F;* 文件名 : Salary.java *&#x2F;public class Salary extends Employee&#123;   private double salary; &#x2F;&#x2F; Annual salary     public double computePay()   &#123;      System.out.println(&quot;Computing salary pay for &quot; + getName());      return salary&#x2F;52;   &#125;    &#x2F;&#x2F;其余代码&#125;</code></pre></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p></li><li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p></li><li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p></li><li><p>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p></li><li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】instanceof</title>
    <link href="/2020/08/27/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Ainstanceof/"/>
    <url>/2020/08/27/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Ainstanceof/</url>
    
    <content type="html"><![CDATA[<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>因为Java是一个面向对象的语言，需要通过创建实例来实现算法，所以Java中有一个instanceof操作符，用来判断实例是否属于某一个类。</p><p>instanceof是一个二元操作符，类似于 ==，&gt;，&lt; 等操作符，返回boolean数据类型。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><pre class="language-none"><code class="language-none">result &#x3D; object instanceof class;</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>Result：布尔类型。<br>Object：必选项。任意对象表达式。<br>Class：必选项。任意已定义的对象类。</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】二叉树</title>
    <link href="/2020/08/26/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/08/26/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="编写二叉树"><a href="#编写二叉树" class="headerlink" title="编写二叉树"></a>编写二叉树</h2><pre class="language-Java" data-language="Java"><code class="language-Java">public class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123; val &#x3D; x; &#125; &#125;</code></pre><h2 id="题目编号"><a href="#题目编号" class="headerlink" title="题目编号"></a>题目编号</h2><p>226 101</p><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>二叉树分为左右节点，首先考虑一个节点，将左右子节点交换，然后递归到左右子节点。结束条件是节点为null</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public TreeNode invertTree(TreeNode root) &#123;        &#x2F;&#x2F; 递归        if(root &#x3D;&#x3D; null) return null;        &#x2F;&#x2F; 创建交换的中间媒介        TreeNode tmp &#x3D; root.right;        &#x2F;&#x2F; 左右子树交换        root.right &#x3D; root.left;        root.left &#x3D; tmp;        &#x2F;&#x2F; 继续递归        invertTree(root.right);        invertTree(root.left);        return root;    &#125;&#125;</code></pre><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>一开始我理解错了，以为就是一个判断根节点的左右子节点是否相等的问题。所以一开始的代码如下：</p><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        if(root &#x3D;&#x3D; null) return true;        while(root !&#x3D; null)&#123;            if(root.left !&#x3D; root.right)&#123;                return false;            &#125;else&#123;                isSymmetric(root.left);                isSymmetric(root.right);            &#125;        &#125;        return true;    &#125;&#125;</code></pre><p>结果带入测试用例答案不对，才发现此题是判断右子节点的右节点和左子节点的左节点还有右子节点的左节点和左子节点的右节点是否相等。<br>这是一个典型递归问题,因为涉及到左子树的子节点和右子树的子节点，所以要另立一个函数isSub(TreeNode L, TreeNode R)来解决。<br>如果左右都为空，则返回true。如果只有其中一个为空或者两个值不相等，则返回false。其他情况则继续向下探索。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        if(root &#x3D;&#x3D; null)&#123;            return true; &#x2F;&#x2F; 根节点为空则返回true        &#125;else&#123;            return isSub(root.left, root.right); &#x2F;&#x2F; 不为空则探索子节点        &#125;    &#125;    public boolean isSub(TreeNode L, TreeNode R)&#123;        if(L &#x3D;&#x3D; null &amp;&amp; R &#x3D;&#x3D; null) return true; &#x2F;&#x2F; 如果左右都为空，则返回true        if(L &#x3D;&#x3D; null || R &#x3D;&#x3D; null || L.val !&#x3D; R.val)&#123;            return false; &#x2F;&#x2F; 如果只有其中一个为空或者两个值不相等，则返回false        &#125;else&#123;            return isSub(L.left, R.right) &amp;&amp; isSub(L.right, R.left); &#x2F;&#x2F; 其他情况则继续向下探索        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈遗传算法：用遗传算法求最大值</title>
    <link href="/2020/08/20/%E8%B0%88%E8%B0%88%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
    <url>/2020/08/20/%E8%B0%88%E8%B0%88%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="遗传算法简介"><a href="#遗传算法简介" class="headerlink" title="遗传算法简介"></a>遗传算法简介</h1><p>遗传算法运用自然界优胜劣汰的法则，可以解决大多数最优解问题，算法过程如下：</p><ol><li>将要解决的问题主体进行编码，形成初始种群。</li><li>用选择函数对种群中的个体进行选择。</li><li>将生存的个体进行交叉，生成子代。</li><li>交叉中设置一定的变异率，防止陷入局部最优解。</li><li>将2.3.4.循环操作最终的到最优种群集合，在其中找到最优解</li></ol><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><blockquote><p>求解函数 2 * math.sin( 2 * x ) + math.cos( 3 * x )在区间[0,9]的最大值。(保留)</p></blockquote><h1 id="遗传算法解决策"><a href="#遗传算法解决策" class="headerlink" title="遗传算法解决策"></a>遗传算法解决策</h1><p>假定需要保留四位小数，那么就一共有90000个可能性，那么</p><center>2^16 < 90000 < 2^17 </center><p><strong>可以将所有可能性都包含在内，下面将其进行二进制的转换</strong></p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_chromosome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># 随机生成染色体变量</span>    <span class="token comment"># a bit ( 0, 1 ) represent a gene</span>    chromosome <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i  <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">:</span>chromosome <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i <span class="token punctuation">)</span> <span class="token operator">*</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>   <span class="token keyword">return</span> chromosome</code></pre><p><strong>将字符二进制编码后还需进行解码，解码我们用</strong></p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">decode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> chromosome<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># 将二进制还原成十进制</span>    <span class="token keyword">return</span> chromosome <span class="token operator">*</span> <span class="token number">9.0</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><p><strong>将得到的种群进行选择，我们要用到题目中所给的选择条件</strong></p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fitness</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> chromosome<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># 解码和适应性函数</span>    x <span class="token operator">=</span> self<span class="token punctuation">.</span>decode<span class="token punctuation">(</span>chromosome<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> math<span class="token punctuation">.</span>sin<span class="token punctuation">(</span> <span class="token number">2</span> <span class="token operator">*</span> x <span class="token punctuation">)</span> <span class="token operator">+</span> math<span class="token punctuation">.</span>cos<span class="token punctuation">(</span> <span class="token number">3</span> <span class="token operator">*</span> x <span class="token punctuation">)</span></code></pre><p><strong>然后进行编写选择模块</strong></p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">selection</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> retain_rate<span class="token punctuation">,</span> random_select_rate<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># 通过适应度大小从大到小进行排序，最后生成的仍然是二进制的列表</span>    graded <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>fitness<span class="token punctuation">(</span>chromosome<span class="token punctuation">)</span><span class="token punctuation">,</span> chromosome<span class="token punctuation">)</span> <span class="token keyword">for</span> chromosome <span class="token keyword">in</span> self<span class="token punctuation">.</span>population<span class="token punctuation">]</span>    graded <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>graded<span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment"># 选出适应性强的染色体,挑选20%作为父类</span>    retain_length <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>graded<span class="token punctuation">)</span> <span class="token operator">*</span> retain_rate<span class="token punctuation">)</span>    parents <span class="token operator">=</span> graded<span class="token punctuation">[</span><span class="token punctuation">:</span>retain_length<span class="token punctuation">]</span>    <span class="token comment"># 从剩余的80%里面选出适应性不强，但是幸存的染色体（概率0.5）</span>    <span class="token keyword">for</span> chromosome <span class="token keyword">in</span> graded<span class="token punctuation">[</span>retain_length<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> random_select_rate<span class="token punctuation">:</span>            parents<span class="token punctuation">.</span>append<span class="token punctuation">(</span>chromosome<span class="token punctuation">)</span>    <span class="token keyword">return</span> parents</code></pre><p><strong>编写交叉模块</strong></p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">crossover</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> parents<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 交叉产生后代</span>    <span class="token comment"># 新出生的孩子，最终会被加入存活下来的父母之中，形成新一代的种群。</span>    children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment"># 需要繁殖的数量</span>    target_count <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>population<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token builtin">len</span><span class="token punctuation">(</span>parents<span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span> <span class="token operator">&lt;</span> target_count<span class="token punctuation">:</span>        malelocation <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>parents<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        femalelocation <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>parents<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        male <span class="token operator">=</span> parents<span class="token punctuation">[</span>malelocation<span class="token punctuation">]</span>        female <span class="token operator">=</span> parents<span class="token punctuation">[</span>femalelocation<span class="token punctuation">]</span>        <span class="token keyword">if</span> malelocation <span class="token operator">!=</span> femalelocation<span class="token punctuation">:</span>            <span class="token comment"># 随机选择交叉点</span>            cross_pos <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>length<span class="token punctuation">)</span>            <span class="token comment"># 生成掩码，方便位运算</span>            mask <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>cross_pos<span class="token punctuation">)</span><span class="token punctuation">:</span>                mask <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i <span class="token punctuation">)</span>            <span class="token comment"># 孩子将获得父亲在交叉点前的基因和母亲在交叉点后（包括交叉点）的基因</span>            child <span class="token operator">=</span> <span class="token punctuation">(</span>male <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>female <span class="token operator">&amp;</span> <span class="token operator">~</span>mask<span class="token punctuation">)</span>            children<span class="token punctuation">.</span>append<span class="token punctuation">(</span>child<span class="token punctuation">)</span>    <span class="token comment"># 经过繁殖后，孩子和父母的数量与原始种群数量相等，在这里可以更新种群。</span>    self<span class="token punctuation">.</span>population <span class="token operator">=</span> parents <span class="token operator">+</span> children</code></pre><p><strong>编写变异模块</strong></p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">mutation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> rate<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 对种群中的所有个体，随机改变某个个体中的某个基因</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>population<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> rate<span class="token punctuation">:</span>            j <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token comment"># 随机取得一个数j对变异基因1进行随机移动</span>            self<span class="token punctuation">.</span>population<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>population<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^</span> <span class="token punctuation">(</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j <span class="token punctuation">)</span>  <span class="token comment"># ^是异或运算</span></code></pre><p>遗传算法求最大值的总体思路就是这样，思想上还是相当简单的，下面我们把所有代码组合起来，加上框架，就可以做成一个完整的<strong>遗传算法求最大值</strong>的程序</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># !/usr/bin/env python</span><span class="token comment"># -*- coding:utf-8 -*-</span><span class="token comment"># 求解函数 2 * math.sin( 2 * x ) + math.cos( 3 * x )在区间[0,9]的最大值。</span><span class="token keyword">import</span> math<span class="token keyword">import</span> random<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">class</span> <span class="token class-name">GA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># initalise</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> length<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 染色体长度</span>        self<span class="token punctuation">.</span>length <span class="token operator">=</span> length        <span class="token comment"># 染色体数量</span>        self<span class="token punctuation">.</span>count <span class="token operator">=</span> count        <span class="token comment"># 形成原始种群</span>        self<span class="token punctuation">.</span>population <span class="token operator">=</span> self<span class="token punctuation">.</span>get_population<span class="token punctuation">(</span>length<span class="token punctuation">,</span> count<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">get_population</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> length<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># get a list of count numbers chromosome (length : length)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>get_chromosome<span class="token punctuation">(</span>length<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">get_chromosome</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 随机生成染色体变量</span>        <span class="token comment"># a bit ( 0, 1 ) represent a gene</span>        chromosome <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i  <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">:</span>            chromosome <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i <span class="token punctuation">)</span> <span class="token operator">*</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>chromosome<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>chromosome <span class="token operator">*</span> <span class="token number">9.0</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> chromosome        <span class="token keyword">def</span> <span class="token function">evolve</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> retain_rate <span class="token operator">=</span> <span class="token number">0.2</span><span class="token punctuation">,</span> random_select_rate <span class="token operator">=</span> <span class="token number">0.5</span><span class="token punctuation">,</span> mutation_rate <span class="token operator">=</span> <span class="token number">0.01</span> <span class="token punctuation">)</span><span class="token punctuation">:</span>                parents <span class="token operator">=</span> self<span class="token punctuation">.</span>selection<span class="token punctuation">(</span>retain_rate<span class="token punctuation">,</span> random_select_rate<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>crossover<span class="token punctuation">(</span>parents<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>mutation<span class="token punctuation">(</span>mutation_rate<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">fitness</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> chromosome<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 解码和适应性函数</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>decode<span class="token punctuation">(</span>chromosome<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> math<span class="token punctuation">.</span>sin<span class="token punctuation">(</span> <span class="token number">2</span> <span class="token operator">*</span> x <span class="token punctuation">)</span> <span class="token operator">+</span> math<span class="token punctuation">.</span>cos<span class="token punctuation">(</span> <span class="token number">3</span> <span class="token operator">*</span> x <span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">selection</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> retain_rate<span class="token punctuation">,</span> random_select_rate<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 通过适应度大小从大到小进行排序，最后生成的仍然是二进制的列表</span>        graded <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>fitness<span class="token punctuation">(</span>chromosome<span class="token punctuation">)</span><span class="token punctuation">,</span> chromosome<span class="token punctuation">)</span> <span class="token keyword">for</span> chromosome <span class="token keyword">in</span> self<span class="token punctuation">.</span>population<span class="token punctuation">]</span>        graded <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>graded<span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">]</span>                <span class="token comment"># 选出适应性强的染色体,挑选20%作为父类</span>        retain_length <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>graded<span class="token punctuation">)</span> <span class="token operator">*</span> retain_rate<span class="token punctuation">)</span>        parents <span class="token operator">=</span> graded<span class="token punctuation">[</span><span class="token punctuation">:</span>retain_length<span class="token punctuation">]</span>                <span class="token comment"># 从剩余的80%里面选出适应性不强，但是幸存的染色体（概率0.5）</span>        <span class="token keyword">for</span> chromosome <span class="token keyword">in</span> graded<span class="token punctuation">[</span>retain_length<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> random_select_rate<span class="token punctuation">:</span>                parents<span class="token punctuation">.</span>append<span class="token punctuation">(</span>chromosome<span class="token punctuation">)</span>        <span class="token keyword">return</span> parents        <span class="token keyword">def</span> <span class="token function">crossover</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> parents<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 交叉产生后代</span>        <span class="token comment"># 新出生的孩子，最终会被加入存活下来的父母之中，形成新一代的种群。</span>        children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 需要繁殖的数量</span>        target_count <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>population<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token builtin">len</span><span class="token punctuation">(</span>parents<span class="token punctuation">)</span>        <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span> <span class="token operator">&lt;</span> target_count<span class="token punctuation">:</span>            malelocation <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>parents<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            femalelocation <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>parents<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            male <span class="token operator">=</span> parents<span class="token punctuation">[</span>malelocation<span class="token punctuation">]</span>            female <span class="token operator">=</span> parents<span class="token punctuation">[</span>femalelocation<span class="token punctuation">]</span>            <span class="token keyword">if</span> malelocation <span class="token operator">!=</span> femalelocation<span class="token punctuation">:</span>                <span class="token comment"># 随机选择交叉点</span>                cross_pos <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                <span class="token comment"># 生成掩码，方便位运算</span>                mask <span class="token operator">=</span> <span class="token number">0</span>                <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>cross_pos<span class="token punctuation">)</span><span class="token punctuation">:</span>                    mask <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i <span class="token punctuation">)</span>                <span class="token comment"># 孩子将获得父亲在交叉点前的基因和母亲在交叉点后（包括交叉点）的基因</span>                child <span class="token operator">=</span> <span class="token punctuation">(</span>male <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>female <span class="token operator">&amp;</span> <span class="token operator">~</span>mask<span class="token punctuation">)</span>                children<span class="token punctuation">.</span>append<span class="token punctuation">(</span>child<span class="token punctuation">)</span>        <span class="token comment"># 经过繁殖后，孩子和父母的数量与原始种群数量相等，在这里可以更新种群。</span>        self<span class="token punctuation">.</span>population <span class="token operator">=</span> parents <span class="token operator">+</span> children        <span class="token keyword">def</span> <span class="token function">mutation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> rate<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 对种群中的所有个体，随机改变某个个体中的某个基因</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>population<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> rate<span class="token punctuation">:</span>                j <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>                <span class="token comment"># 随机取得一个数j对变异基因1进行随机移动</span>                self<span class="token punctuation">.</span>population<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>population<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^</span> <span class="token punctuation">(</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j <span class="token punctuation">)</span>  <span class="token comment"># ^是异或运算</span>    <span class="token keyword">def</span> <span class="token function">decode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> chromosome<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 将二进制还原成十进制</span>        <span class="token keyword">return</span> chromosome <span class="token operator">*</span> <span class="token number">9.0</span><span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">result</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 获得当前最优的个体值</span>        graded <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>fitness<span class="token punctuation">(</span>chromosome<span class="token punctuation">)</span><span class="token punctuation">,</span> chromosome<span class="token punctuation">)</span> <span class="token keyword">for</span> chromosome <span class="token keyword">in</span> self<span class="token punctuation">.</span>population<span class="token punctuation">]</span>        graded <span class="token operator">=</span> <span class="token punctuation">[</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>graded<span class="token punctuation">,</span> reverse <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        X1 <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token operator">/</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        Y1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> math<span class="token punctuation">.</span>sin<span class="token punctuation">(</span> <span class="token number">2</span> <span class="token operator">*</span> x <span class="token punctuation">)</span> <span class="token operator">+</span> math<span class="token punctuation">.</span>cos<span class="token punctuation">(</span> <span class="token number">3</span> <span class="token operator">*</span> x <span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> X1<span class="token punctuation">]</span>        plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>X1<span class="token punctuation">,</span> Y1<span class="token punctuation">)</span>        plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> ga<span class="token punctuation">.</span>decode<span class="token punctuation">(</span>graded<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment"># 染色体长度为17，群落数量是300</span>    ga <span class="token operator">=</span> GA<span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        ga<span class="token punctuation">.</span>evolve<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'x = %f'</span> <span class="token operator">%</span><span class="token punctuation">(</span>ga<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>遗传算法在思想上还是很简单的存在，并且可以通过变异避免陷入局部最优解，但是缺点也很明显，因为要通过不停迭代不停选择，所以运行时间比较长，而且种群数量变大的话，对于电脑的资源消耗也变高。  </p></li><li><p>遗传算法的难点在于对于现实中的物体进行编码，并且染色体交叉后是否会出现不合规的染色体，比如在用遗传算法解决pick up and delivery问题上，配送的先后顺序也要考虑到，这些都是今后需要考虑的点。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>谈谈技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>遗传算法</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【剑指offer】50. 第一个只出现一次的字符</title>
    <link href="/2020/08/19/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A50/"/>
    <url>/2020/08/19/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A50/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a>剑指 Offer 50. 第一个只出现一次的字符</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class="language-none"><code class="language-none">s &#x3D; &quot;abaccdeff&quot;返回 &quot;b&quot;s &#x3D; &quot;&quot; 返回 &quot; &quot;</code></pre><h2 id="解题思路1"><a href="#解题思路1" class="headerlink" title="解题思路1"></a>解题思路1</h2><p>跟<a href="https://liuminxuan.github.io/2020/08/18/Leetcodes%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/">leetcode387</a>差不多，只是返回值不一样，稍加修改就可以提交了。<br>用数组自创哈希表，因为只有小写字母，所以设置一个26长度的数组，字符串中出现一次，数组里对应的字母就+1，然后再对字符串的字母一一对照，如果值为1就输出，找不到1则无解。</p><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public char firstUniqChar(String s) &#123;       int[] count &#x3D; new int[26]; &#x2F;&#x2F; 因为都是小写字母，所以数组取26        char[] chars &#x3D; s.toCharArray();         for(char c : chars)&#123;            count[c-&#39;a&#39;]++; &#x2F;&#x2F; 因为是ASCII码字母出现一次+1        &#125;        for(int i &#x3D; 0;i&lt;s.length();i++)&#123;            if(count[s.charAt(i)-&#39;a&#39;] &#x3D;&#x3D; 1)&#123;                return s.charAt(i); &#x2F;&#x2F; 找出只出现一次的字母            &#125;        &#125;        return &#39; &#39;; &#x2F;&#x2F; 无解    &#125;&#125;</code></pre><h2 id="解题思路2"><a href="#解题思路2" class="headerlink" title="解题思路2"></a>解题思路2</h2><p>除去用数组做，第一印象肯定是HashMap，但是其结果却不尽人意。<br>究其原因，HashMap是由一个链表组成，其查找速度必然不如O(1)的数组，但是在插入和删除操作的时候，其查找速度比数组快。</p><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public char firstUniqChar(String s) &#123;        &#x2F;&#x2F; 数组为空，返回空        if(s.isEmpty()) return &#39; &#39;;        HashMap&lt;Character, Integer&gt; map &#x3D; new HashMap&lt;&gt;();        char c &#x3D; &#39; &#39;;        &#x2F;&#x2F; 遍历字符串，分别放入HashMap，第一次放入则值为0        &#x2F;&#x2F; 而后出现相同的时候取出Key对应的value，然后将value+1，放回Key对应的value中        for(int i &#x3D; 0;i &lt; s.length(); i++)&#123;            c &#x3D; s.charAt(i);            if(!map.containsKey(c))&#123;                map.put(c, 0);            &#125;else&#123;                &#x2F;&#x2F; map.put(c, 1);                int v &#x3D; map.get(c);                &#x2F;&#x2F; map.remove(c);                v++;                map.put(c, v);            &#125;        &#125;        &#x2F;&#x2F;         for(int i &#x3D; 0;i &lt; s.length(); i++)&#123;            c &#x3D; s.charAt(i);            if (map.get(c) &#x3D;&#x3D; 0) &#123;                return c;            &#125;        &#125;        return &#39; &#39;;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>剑指offer刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】字符串</title>
    <link href="/2020/08/18/Leetcodes%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2020/08/18/Leetcodes%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目编号"><a href="#题目编号" class="headerlink" title="题目编号"></a>题目编号</h2><p>38 387</p><h2 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38.外观数列"></a>38.外观数列</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为后一项是前一项决定的，所以用循环来做。<br>选取第一个数，然后数后面有多少相同，最后用appned加上去。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public String countAndSay(int n) &#123;        String str &#x3D; &quot;1&quot;; &#x2F;&#x2F; 第一个数        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;            StringBuilder sb &#x3D; new StringBuilder();            char pre &#x3D; str.charAt(0); &#x2F;&#x2F; 取出头部的数字            int count &#x3D; 1;            for (int j &#x3D; 1; j &lt; str.length(); j++) &#123;                &#x2F;&#x2F; 如果后面的数与第一个相同，则count++                &#x2F;&#x2F; 否则用append方法将头部数字的个数和头部数字加入字符串中                if(pre &#x3D;&#x3D; str.charAt(j))&#123;                    count++;                &#125;else&#123;                    sb.append(count).append(pre);                    pre &#x3D; str.charAt(j); &#x2F;&#x2F; 选取下一个头部数字                    count &#x3D; 1; &#x2F;&#x2F; count归1                &#125;            &#125;            &#x2F;&#x2F; 最后跳出循环时未处理最后一个头部数字，在此在此处理            sb.append(count).append(pre);            str &#x3D; sb.toString();        &#125;        return str;    &#125;&#125;</code></pre><h2 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>用数组自创哈希表，因为只有小写字母，所以设置一个26长度的数组，字符串中出现一次，数组里对应的字母就+1，然后再对字符串的字母一一对照，如果值为1就输出，找不到1则无解。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public int firstUniqChar(String s) &#123;        int count[] &#x3D; new int[26];        for(int i&#x3D;0;i&lt;s.length();i++)&#123;            count[s.charAt(i)-&#39;a&#39;]++;        &#125;        for(int i&#x3D;0;i&lt;s.length();i++)&#123;            if(count[s.charAt(i)-&#39;a&#39;] &#x3D;&#x3D; 1)&#123;                return i;            &#125;        &#125;        return -1;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】36. 有效的数独</title>
    <link href="/2020/08/17/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/"/>
    <url>/2020/08/17/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36.有效的数独"></a>36.有效的数独</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>第一想到的是哈希表，所以给每一行每一列每个九宫格设置一个哈希表，出现数字则标记，如果查询到被标记过的数字，则数独不成立。<br>每行每列比较简单，设置一个9*10的数组就可以解决，9是数独的行和列，10是数独里面所填的值。比较数独里九宫格里的数就比较复杂，我们可以利用int做除法只能取整的特性求解。<br>比如第一第二个九宫格<br>(0,0) -&gt; 0<br>(0,1) -&gt; 0<br>(0,2) -&gt; 0<br>(1,0) -&gt; 0<br>(1,1) -&gt; 0<br>(1,2) -&gt; 0<br>(2,0) -&gt; 0<br>(2,1) -&gt; 0<br>(2,2) -&gt; 0</p><p>(0,3) -&gt; 3<br>(0,4) -&gt; 3<br>(0,5) -&gt; 3<br>(1,3) -&gt; 3<br>(1,4) -&gt; 3<br>(1,5) -&gt; 3<br>(2,3) -&gt; 3<br>(2,4) -&gt; 3<br>(2,5) -&gt; 3</p><p>可以看出九个九宫格可以填入9*10的哈希表</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public boolean isValidSudoku(char[][] board) &#123;        int[][] row &#x3D; new int[9][10]; &#x2F;&#x2F; 记录行        int[][] col &#x3D; new int[9][10]; &#x2F;&#x2F; 记录列        int[][] box &#x3D; new int[9][10]; &#x2F;&#x2F; 记录九宫格        init(row);        init(col);        init(box);        for (int i &#x3D; 0; i &lt; 9; i++) &#123;            for (int j &#x3D; 0; j &lt; 9; j++) &#123;                if (board[i][j] &#x3D;&#x3D; &#39;.&#39;) continue;                int compare &#x3D; board[i][j] - &#39;0&#39;;                if (row[i][compare] !&#x3D; 0) return false;                if (col[j][compare] !&#x3D; 0) return false;                if(box[i&#x2F;3+(j&#x2F;3)*3][compare] !&#x3D; 0) return false; &#x2F;&#x2F;利用int特性分离九宫格                row[i][compare]++; &#x2F;&#x2F; 标记查询过的行                col[j][compare]++; &#x2F;&#x2F; 标记查询过的列                box[i&#x2F;3+(j&#x2F;3)*3][compare]++;            &#125;        &#125;        return true;    &#125;    &#x2F;&#x2F; 初始化    private int[][] init(int[][] matrix) &#123;        for (int i &#x3D; 0; i &lt; 9; i++) &#123;            for (int j &#x3D; 0; j &lt; 10; j++) &#123;                matrix[i][j] &#x3D; 0;            &#125;        &#125;        return matrix;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】equals方法</title>
    <link href="/2020/05/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Aequals%E6%96%B9%E6%B3%95/"/>
    <url>/2020/05/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Aequals%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>equals方法可以比较两个对象是否相等。</p><h2 id="String类型比较"><a href="#String类型比较" class="headerlink" title="String类型比较"></a>String类型比较</h2><p>每次创建一个String对象都是创建一个新的对象，但是创建的时候如果String不是很长，Java会在已创建的String对象里寻找相同的对象然后指向它。</p><p>但是当String非常长的时候，Java会直接创建对象，所以比较两个String对象的时候，不要用”==”,要用equals方法。</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】滑动窗口</title>
    <link href="/2020/05/03/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2020/05/03/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="题目编号"><a href="#题目编号" class="headerlink" title="题目编号"></a>题目编号</h2><p>3 209</p><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>一开始以子串的长度为基准，发现循环中的代码非常复杂，一不注意就出错，后来看了评论才知道应该以左边的数字为基准，外层循环遍历整个字符串，内层循环遍历当前子串是否有相同的字符。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public int lengthOfLongestSubstring(String s) &#123;        int maxCount &#x3D; 0;        int left &#x3D; 0; &#x2F;&#x2F; 左边的那个数        char[] sToChar &#x3D; s.toCharArray();        for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;            for (int in &#x3D; left; in &lt; i; in++) &#123;                if (sToChar[in] &#x3D;&#x3D; sToChar[i]) &#123;                    maxCount &#x3D; Math.max(maxCount, i - left);                    left &#x3D; in + 1;                    break;                &#125;            &#125;        &#125;        maxCount &#x3D; Math.max(maxCount, sToChar.length - left);        return maxCount;    &#125;&#125;</code></pre><a id="more"></a><h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>暴力破解法：</p><ul><li>从第一个数开始往后加，加到满足条件看有几个元素，</li><li>从第二个数开始往后加，加到满足条件看有几个元素，然后跟第一个比较，</li><li>从第三个数开始往后加，加到满足条件看有几个元素，然后跟第二个比较，</li><li>。。。得出结果</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;   public int minSubArrayLen(int s, int[] nums) &#123;        int len &#x3D; nums.length + 1;        int i &#x3D; 0;        for (; i &lt; nums.length; i++) &#123;            int right &#x3D; i;            int sum &#x3D; 0;            for (; right &lt; nums.length; right++) &#123;                sum +&#x3D; nums[right];                if (sum &gt;&#x3D; s) &#123;                    &#x2F;&#x2F; 这里因为i已经加了1，但是right还没加1，所以得把1补过来                    len &#x3D; Math.min(len, right - i + 1);                    break;                &#125;            &#125;        &#125;        return len &#x3D;&#x3D; nums.length + 1 ? 0 : len;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】67. 二进制求和</title>
    <link href="/2020/05/03/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E2%80%9C/"/>
    <url>/2020/05/03/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E2%80%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目编号"><a href="#题目编号" class="headerlink" title="题目编号"></a>题目编号</h2><p>67</p><h2 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a>67. 二进制求和</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>之前在Java学习笔记中写到过<a href="https://liuminxuan.github.io/2020/01/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BD%8D%E8%BF%90%E7%AE%97/">位运算</a>，这次在Leetcode中也遇到了，二进制只有1和0，所以将位运算加入其中，计算完一位后就将进位数移位，进行下一轮计算。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public String addBinary(String a, String b) &#123;      if(a &#x3D;&#x3D; null || a.length() &#x3D;&#x3D; 0) return b; &#x2F;&#x2F;         if(b &#x3D;&#x3D; null || b.length() &#x3D;&#x3D; 0) return a;        StringBuilder stb &#x3D; new StringBuilder();        int i &#x3D; a.length() - 1;        int j &#x3D; b.length() - 1;        int c &#x3D; 0;  &#x2F;&#x2F; 进位        while(i &gt;&#x3D; 0 || j &gt;&#x3D; 0) &#123;            if(i &gt;&#x3D; 0) c +&#x3D; a.charAt(i --) - &#39;0&#39;; &#x2F;&#x2F; 进位数与a相加            if(j &gt;&#x3D; 0) c +&#x3D; b.charAt(j --) - &#39;0&#39;; &#x2F;&#x2F; 进位数与b相加            stb.append(c % 2);            c &gt;&gt;&#x3D; 1; &#x2F;&#x2F; 移位运算        &#125;        String res &#x3D; stb.reverse().toString(); &#x2F;&#x2F; 字符串反转        return c &gt; 0 ? &#39;1&#39; + res : res; &#x2F;&#x2F;判断进位      &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】贪心</title>
    <link href="/2020/04/30/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%B4%AA%E5%BF%83/"/>
    <url>/2020/04/30/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h2 id="题目编号"><a href="#题目编号" class="headerlink" title="题目编号"></a>题目编号</h2><p>53 121</p><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为负数加负数更小，所以当目前总和为负数时，跟下一个负数只取一个较大的负数。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">public int maxSubArray(int[] nums) &#123;        int[] dt &#x3D; new int[nums.length];        dt[0] &#x3D; nums[0];        int maxSum &#x3D; nums[0];        for (int i &#x3D; 1; i &lt; nums.length; i++) &#123;            &#x2F;&#x2F; 找出正数最多的子序列            &#x2F;&#x2F; 负数相加只会越来越小，所以当总和小于零时遇上负数直接把前面舍弃            dt[i] &#x3D; Math.max(dt[i - 1],0) + nums[i];            if (dt[i] &gt; maxSum) &#123;                &#x2F;&#x2F;因为会遍历到底，所以要记录遍历途中最大的数                maxSum &#x3D; dt[i];            &#125;        &#125;        return maxSum;    &#125;</code></pre><a id="more"></a><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为只买卖一次，所以只要找到最大值前面的最小值就行了，每次模拟买入卖出情况，找出最大差值，解决问题。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">class Solution &#123;    public int maxProfit(int[] prices) &#123;&#x2F;&#x2F; 输入为空时，返回0        if (prices.length &#x3D;&#x3D; 0) return 0;        int buy &#x3D; prices[0];        int profit &#x3D; 0;        int maxProfit &#x3D; 0;        for (int i &#x3D; 1; i &lt; prices.length; i++) &#123;            if (prices[i] &lt; buy) &#123;                &#x2F;&#x2F; 模拟买入，如果买入价格比之前低，就买入备选                buy &#x3D; prices[i];            &#125; else if (prices[i] &gt; buy) &#123;                &#x2F;&#x2F; 每次模拟卖出的情况                profit &#x3D; prices[i] - buy;                if (profit &gt; maxProfit) &#123;                    &#x2F;&#x2F; 如果利润大于最大利润，就卖出备选                    maxProfit &#x3D; profit;                &#125;            &#125;        &#125;        return maxProfit;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Leetcode】链表</title>
    <link href="/2020/04/26/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/04/26/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="题目编号"><a href="#题目编号" class="headerlink" title="题目编号"></a>题目编号</h1><p>206 141 21 19 876 160</p><h2 id="编写链表"><a href="#编写链表" class="headerlink" title="编写链表"></a>编写链表</h2><pre class="language-Java" data-language="Java"><code class="language-Java">public class ListNode &#123;        int val;        ListNode next;        ListNode(int x) &#123;            val &#x3D; x;        &#125;    &#125;</code></pre><a id="more"></a><h1 id="易犯错误"><a href="#易犯错误" class="headerlink" title="易犯错误"></a>易犯错误</h1><ul><li>最近遇到一个问题：</li></ul><hr><p> head   –&gt; val = 6 –&gt; val = 13 –&gt; val = 17 –&gt; val = 21</p><hr><p>求head.next.next.val = ?</p><ul><li>解题思路：<br>因为头指针head只指向头节点所在的地址，并不包含数据，所以不能把头指针看作一个节点，所以head.next.next.val = 17.</li></ul><h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>类似于选择排序中交换两个数的位置。借助一个tmp完成交换</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">public ListNode reverseList(ListNode head) &#123;        ListNode pre &#x3D; null; &#x2F;&#x2F; 前元素        ListNode cur &#x3D; head; &#x2F;&#x2F; 正在操作的元素        ListNode tmp &#x3D; null; &#x2F;&#x2F; 临时元素        while (cur !&#x3D; null) &#123;            tmp &#x3D; cur.next;             cur.next &#x3D; pre;            pre &#x3D; cur;            cur &#x3D; tmp;        &#125;        return pre;    &#125;</code></pre><h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为如果是环形链表，一定会陷入无限循环。所以用快慢指针解决。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">public boolean hasCycle(ListNode head) &#123;        if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) &#123;            return false;        &#125;        ListNode low &#x3D; head;        ListNode fast &#x3D; head.next;        while (fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null) &#123;            if(fast.equals(low))&#123;                &#x2F;&#x2F; 慢指针追上了快指针                return true;            &#125;            low &#x3D; low.next;            fast &#x3D; fast.next.next;        &#125;        return false;    &#125;</code></pre><h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h1><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>创建一个新链表，比较l1、l2两个链表的大小，将小的放进新链表。最后将剩余的接在新链表后面。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;        ListNode dummy &#x3D; new ListNode(-1);        ListNode curr &#x3D; dummy;        while (l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null) &#123;            if (l1.val &lt; l2.val) &#123;                curr.next &#x3D; l1;                curr &#x3D; curr.next;                l1 &#x3D; l1.next;            &#125; else if (l1.val &gt;&#x3D; l2.val) &#123;                curr.next &#x3D; l2;                curr &#x3D; curr.next;                l2 &#x3D; l2.next;            &#125;        &#125;        if (l1 !&#x3D; null) &#123;            &#x2F;&#x2F; 如果l1有剩余，将剩余元素接上去            curr.next &#x3D; l1;        &#125; else if (l2 !&#x3D; null) &#123;            &#x2F;&#x2F; 与l1同理            curr.next &#x3D; l2;        &#125;        &#x2F;&#x2F; 装逼写法        &#x2F;&#x2F; cur.next &#x3D; l1 &#x3D;&#x3D; null ? l2 : l1;        return dummy.next;    &#125;</code></pre><h1 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h1><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>用快慢指针，中间相隔n个数，快指针到末尾时，慢指针指向的下一个元素就是要删除的节点。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode dummy &#x3D; new ListNode(0);        dummy.next &#x3D; head;        ListNode low &#x3D; dummy;        ListNode fast &#x3D; dummy;        for (int i &#x3D; 0; i &lt; n; i++) &#123;            fast &#x3D; fast.next;        &#125;        while (fast.next !&#x3D; null) &#123;            fast &#x3D; fast.next;            low &#x3D; low.next;        &#125;        if (low.next.next &#x3D;&#x3D; null) &#123;            low.next &#x3D; null;        &#125; else &#123;            low.next &#x3D; low.next.next;        &#125;        return dummy.next;    &#125;</code></pre><h1 id="876-链表的中间节点"><a href="#876-链表的中间节点" class="headerlink" title="876. 链表的中间节点"></a>876. 链表的中间节点</h1><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>先遍历链表数出有多少个元素，第（k/2+1）个元素就是中间元素。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">public ListNode middleNode(ListNode head) &#123;       ListNode dummy &#x3D; new ListNode(0);       dummy.next &#x3D; head;       ListNode low &#x3D; dummy;       ListNode fast &#x3D; dummy;       int k &#x3D; 0;       while (fast.next !&#x3D; null) &#123;           fast &#x3D; fast.next;           k++;       &#125;       for (int i &#x3D; 0; i &lt; k &#x2F; 2 + 1; i++) &#123;           low &#x3D; low.next;       &#125;       return low.next;   &#125;</code></pre><h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h1><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://pic.leetcode-cn.com/e0efdd908a8941e3c53a68a6049d88c437b8299e48540a772ab091b86695d981-image.png" alt="avatar"></p><p>首先初始化pA，pB开始遍历。当pA到尾巴的时候，回到pB开始遍历。pB同理。<br>这样pA的路线a+c+b，pB的路线b+c+a，可知他们如果有交点，一定在遍历的尾巴处。</p><p>如果两个链表没有相交，那么就变成了pA为a+b，pB为b+a，最终他们一定会遍历到null，所以返回其中一个即可。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre class="language-Java" data-language="Java"><code class="language-Java">public class Solution &#123;    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        ListNode pA &#x3D; headA;        ListNode pB &#x3D; headB;        while(pA !&#x3D; pB)&#123;            pA &#x3D; pA &#x3D;&#x3D; null ? headB : pA.next;            pB &#x3D; pB &#x3D;&#x3D; null ? headA : pB.next;        &#125;        return pA;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】访问限制修饰符</title>
    <link href="/2020/04/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2020/04/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="public"><a href="#public" class="headerlink" title="public"></a>public</h1><p>范围最广，可以访问任何一个在CLASSPATH下的类，接口，异常等。它往往对于对外的情况，也就是对象或类对外的一种接口的形式。</p><h1 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h1><p>对本包可见，同时也是为继承设计的访问修饰符，即使子类在包外也可访问父类的protect变量或方法。</p><h1 id="defult"><a href="#defult" class="headerlink" title="defult"></a>defult</h1><p>可以供类内部和本包中使用，任何处于本包下的类，接口，异常等，都可以互相访问，即使是父类没有用protected修饰的成员也可以。</p><h1 id="private"><a href="#private" class="headerlink" title="private"></a>private</h1><p>限制最严格的访问修饰符，仅供类内部访问。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>类内部</th><th>本包</th><th>子类</th><th>外部包</th></tr></thead><tbody><tr><td>private</td><td></td><td></td><td></td></tr><tr><td>default</td><td>default</td><td></td><td></td></tr><tr><td>protect</td><td>protect</td><td>protect</td><td>protect</td></tr><tr><td>public</td><td>public</td><td>public</td><td>public</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】构造方法</title>
    <link href="/2020/04/07/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <url>/2020/04/07/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>构造方法是类里的一个特殊的方法，他不能有返回值（包括void）。所谓构造方法，就是这个类在被实例化时（创建对象时）就要执行的方法，方法名为类的名字，一般的目的是为了给类进行一些初始化值。</p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><pre class="language-Java" data-language="Java"><code class="language-Java">public MerchandiseV2WithConstructor(String name, String id, int count,                                        double soldPrice, double purchasePrice) &#123;        this.name &#x3D; name;        this.id &#x3D; id;        this.count &#x3D; count;        this.soldPrice &#x3D; soldPrice;        this.purchasePrice &#x3D; purchasePrice;    &#125;</code></pre><h1 id="构造方法的继承"><a href="#构造方法的继承" class="headerlink" title="构造方法的继承"></a>构造方法的继承</h1><p>子类创建构造方法中一定会创建一个父类的构造方法，所以this和super不可以共存。</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】面向对象三要素</title>
    <link href="/2020/04/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E8%A6%81%E7%B4%A0/"/>
    <url>/2020/04/06/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E8%A6%81%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h1><p>用访问限制符(private)保护成员变量，用public将方法写在类里，在主函数中调用类中的方法，为封装。</p><h1 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h1><p>子类继承父类的成员变量和方法，并且可以在此基础上扩展出自己的成员变量和方法。父类中的private子类不可访问。</p><h1 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h1><p>子类可以用相同的方法名去覆盖父类的方法，同一种方法用覆盖(override)实现不同的结果就是多态。继承关系是必须的。</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】方法的重载和覆盖及参数的匹配规则</title>
    <link href="/2020/04/03/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E5%8F%8A%E5%8F%82%E6%95%B0%E7%9A%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
    <url>/2020/04/03/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E5%8F%8A%E5%8F%82%E6%95%B0%E7%9A%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="重载-overload"><a href="#重载-overload" class="headerlink" title="重载 overload"></a>重载 overload</h1><p>同一个类中如果有两个方法的方法名相同，但参数不一致，那么可以说一个方法是另一个方法的重载(overload)。</p><h1 id="覆盖-override"><a href="#覆盖-override" class="headerlink" title="覆盖 override"></a>覆盖 override</h1><p>继承中如果子类出现与父类相同的方法名与参数，则子类方法可以覆盖(overload)父类方法。调用的方法是对象所存在的那个引用中的方法</p><h1 id="重载的参数匹配规则"><a href="#重载的参数匹配规则" class="headerlink" title="重载的参数匹配规则"></a>重载的参数匹配规则</h1><p>依次使用byte, short, int, long, float, double 类型的参数调用方法。实参可以自动类型转换成高精度的形参，但是高精度不能转换成低精度。</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】堆和栈</title>
    <link href="/2020/03/26/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A0%86%E5%92%8C%E6%A0%88/"/>
    <url>/2020/03/26/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A0%86%E5%92%8C%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<ol><li>一些基本类型的变量和对象的引用变量都是在方法的栈(stack)中分配。</li><li>堆(heap)用于存放由new创建的对象和数组。</li></ol><ul><li>Java基本数据类型：共有8种，即int, short, long, byte, float, double, boolean, char。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】数组</title>
    <link href="/2020/01/21/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E7%BB%84/"/>
    <url>/2020/01/21/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>以前学数组，总是学的稀里糊涂，对数组的生成以及对数组内存储数的查找并不明白是怎么一回事。</p><p>最近温习Java的数组操作，对数组也有了一点更深的认识。</p><p>先来看一段程序:</p><pre class="language-Java" data-language="Java"><code class="language-Java">public class WhatIsArray &#123;    public static void main(String[] args) &#123;                int[] book &#x3D; new int[100];        book[0] &#x3D; 3;        System.out.println(book[0]);        book &#x3D; new int[3];        System.out.println(book[0]);    &#125;&#125;</code></pre><a id="more"></a><p>计算机生成数组的过程如下：</p><ol><li>计算机在内存中找到一个地址并将这个地址取值为book。</li><li>计算机在内存中找到能放下int[100]的地方，并记录数组首地址。</li><li>计算机将int[]首地址记录到book那一页。</li></ol><p>计算机查找数组中的元素过程如下：</p><ol><li>计算机找到book的地址。</li><li>在book中查找数组book[0]首地址。</li><li>将首地址加上数组的下标，找到要找的值。</li></ol><p>由此可以看出为什么数组下标是从“0”开始的，因为这样计算机查找的时候就直接加上下标数就行了，免去了一次减法的操作。</p><p>这种数据类型<strong>需要分两步查找</strong>，所以在Java中，这种数据类型<strong>不是</strong>Java的基本数据类型。</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Java学习】关于位运算</title>
    <link href="/2020/01/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2020/01/20/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>这几天重温Java，发现一个比较有意思的运算，位运算。</p><p>以前只在计算机组成原理这门课中学过位运算，一直以为学习位运算只是为了了解计算机的运算过程以及组成原理。没想到位运算在Java语言中也有很大的作用。</p><h2 id="位运算基础"><a href="#位运算基础" class="headerlink" title="位运算基础"></a>位运算基础</h2><p>位运算主要有三种运算，分别为“与(AND)”，“或(OR)”，“异或(XOR)”。</p><p>另外还有一个移位。</p><a id="more"></a><h2 id="位运算的应用"><a href="#位运算的应用" class="headerlink" title="位运算的应用"></a>位运算的应用</h2><p>位运算因为只有1和0，所以可以用于身份认证，这里举出一个判断身份的Java程序。</p><pre class="language-Java" data-language="Java"><code class="language-Java">public class BitChoose &#123;        public static void main(String[] arg)&#123;        int base &#x3D; 1;        int is_student_mask &#x3D; base; &#x2F;&#x2F;0001        int is_teacher_mask &#x3D; base &lt;&lt; 1; &#x2F;&#x2F;0010        int is_police_mask &#x3D; base &lt;&lt; 2; &#x2F;&#x2F;0100        int is_doctor_mask &#x3D; base &lt;&lt; 3; &#x2F;&#x2F;1000        int data &#x3D; 3; &#x2F;&#x2F;0011        boolean is_student &#x3D; (data &amp; is_student_mask) !&#x3D; 0;        System.out.println(is_student);        boolean is_teacher &#x3D; (data &amp; is_teacher_mask) !&#x3D; 0;        System.out.println(is_teacher);        boolean is_police &#x3D; (data &amp; is_police_mask) !&#x3D; 0;        System.out.println(is_police);        boolean is_doctor &#x3D; (data &amp; is_police_mask) !&#x3D; 0;        System.out.println(is_doctor);    &#125;&#125;</code></pre><p>可以看出位运算可以通过”掩码“和“与”运算实现身份识别功能。</p>]]></content>
    
    
    <categories>
      
      <category>Java学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】动态规划</title>
    <link href="/2019/03/27/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2019/03/27/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p>假如有个小偷，背着可装4磅东西的背包，可盗窃的物品有如下三件：</p><table><thead><tr><th align="center">音响</th><th align="center">笔记本电脑</th><th align="center">吉他</th></tr></thead><tbody><tr><td align="center">3000美元</td><td align="center">2000美元</td><td align="center">1500美元</td></tr><tr><td align="center">4磅</td><td align="center">3磅</td><td align="center">1磅</td></tr></tbody></table><p>为了让盗窃的总价值最高，该选择哪些商品？</p><a id="more"></a><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p><strong>动态规划解法做成了如下的表格：</strong></p><table><thead><tr><th align="center"></th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">吉他</td><td align="center">1500美元(G)</td><td align="center">1500美元(G)</td><td align="center">1500美元(G)</td><td align="center">1500美元(G)</td></tr><tr><td align="center">音响</td><td align="center">1500美元(G)</td><td align="center">1500美元(G)</td><td align="center">1500美元(G)</td><td align="center">3000美元(S)</td></tr><tr><td align="center">笔记本电脑</td><td align="center">1500美元(G)</td><td align="center">1500美元(G)</td><td align="center">2000美元(L)</td><td align="center">3500美元(LG)</td></tr></tbody></table><p><strong>答案：将吉他和笔记本电脑装入背包时价值最高，为3500美元。</strong></p><p>计算每个单元格价值时，运用如下公式：</p><p>cell[i][j] =<br>max{ 上一个单元格的值(cell[i-1][j]) ，当前商品价值(cell[i][j-1])+剩余空间价值(cell[i-1][j-当前物品重量])</p><h2 id="代码表现"><a href="#代码表现" class="headerlink" title="代码表现"></a>代码表现</h2><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># -*- coding: utf-8 -*-</span><span class="token keyword">def</span> <span class="token function">bag</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>c<span class="token punctuation">,</span>w<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>    res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment">#第0行全部赋值为0，物品编号从1开始.为了下面赋值方便</span>        res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>res<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>            <span class="token keyword">print</span> res            <span class="token comment">#生成了n*c有效矩阵，以下公式w[i-1],p[i-1]代表从第一个元素w[0],p[0]开始取。</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>w<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">and</span> res<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>p<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>res<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>p<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> res<span class="token comment">#以下代码功能：标记出有放入背包的物品</span><span class="token comment">#反过来标记，在相同价值情况下，后一件物品比前一件物品的最大价值大，则表示物品i#有被加入到背包，x数组设置为True。设初始为j=c。</span><span class="token keyword">def</span> <span class="token function">show</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>c<span class="token punctuation">,</span>w<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span> <span class="token string">'最大价值为:'</span><span class="token punctuation">,</span>res<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span>    x<span class="token operator">=</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>    j<span class="token operator">=</span>c    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>res<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            x<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span>            j<span class="token operator">-=</span>w<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">print</span> <span class="token string">'选择的物品为:'</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">print</span> <span class="token string">'第'</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token string">'个,'</span>    <span class="token keyword">print</span><span class="token string">''</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>    n<span class="token operator">=</span><span class="token number">3</span>    c<span class="token operator">=</span><span class="token number">4</span>    w<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token comment">#这里重量要按从小到大排序</span>    p<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1500</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">]</span>    res<span class="token operator">=</span>bag<span class="token punctuation">(</span>n<span class="token punctuation">,</span>c<span class="token punctuation">,</span>w<span class="token punctuation">,</span>p<span class="token punctuation">)</span>    show<span class="token punctuation">(</span>n<span class="token punctuation">,</span>c<span class="token punctuation">,</span>w<span class="token punctuation">,</span>res<span class="token punctuation">)</span></code></pre><p>理论上来说，第33行的重量无所谓顺序，但是此算法转化为代码时，因为代码的一些缺陷，导致必须要按从小到大排序才能使程序顺利运行。</p><h1 id="旅行行程最优化"><a href="#旅行行程最优化" class="headerlink" title="旅行行程最优化"></a>旅行行程最优化</h1><p>假设你要去伦敦度假，假期两天，你想去浏览的地方很多，但是没法全部浏览到，因此有如下的单子：</p><table><thead><tr><th align="center">名胜</th><th align="center">时间</th><th align="center">评分</th></tr></thead><tbody><tr><td align="center">威斯敏斯特教堂</td><td align="center">0.5天</td><td align="center">7</td></tr><tr><td align="center">环球剧场</td><td align="center">0.5天</td><td align="center">6</td></tr><tr><td align="center">英国国家美术馆</td><td align="center">1天</td><td align="center">9</td></tr><tr><td align="center">大英博物馆</td><td align="center">2天</td><td align="center">9</td></tr><tr><td align="center">圣保罗大教堂</td><td align="center">0.5天</td><td align="center">8</td></tr></tbody></table><p>这也可以转化为一个背包问题，可列出如下列表：</p><table><thead><tr><th align="center"></th><th align="center">1/2</th><th align="center">1</th><th align="center">3/2</th><th align="center">2</th></tr></thead><tbody><tr><td align="center">威斯敏斯特教堂(W)</td><td align="center">7(W)</td><td align="center">7(W)</td><td align="center">7(W)</td><td align="center">7(W)</td></tr><tr><td align="center">环球剧场(G)</td><td align="center">7(W)</td><td align="center">13(WG)</td><td align="center">13(WG)</td><td align="center">13(WG)</td></tr><tr><td align="center">英国国家美术馆(N)</td><td align="center">7(W)</td><td align="center">13(WG)</td><td align="center">16(WN)</td><td align="center">22(WGN)</td></tr><tr><td align="center">大英博物馆(B)</td><td align="center">7(W)</td><td align="center">13(WG)</td><td align="center">16(WN)</td><td align="center">22(WGN)</td></tr><tr><td align="center">圣保罗大教堂(S)</td><td align="center">7(W)</td><td align="center">15(WS)</td><td align="center">21(WGS)</td><td align="center">24(WNS)</td></tr></tbody></table><h1 id="动态规划问题特征"><a href="#动态规划问题特征" class="headerlink" title="动态规划问题特征"></a>动态规划问题特征</h1><ul><li>动态规划问题可以在给定约束条件下找到最优解。</li><li>问题可分解成彼此独立且离散的子问题时，就可使用动态规划来解决。</li><li>每种动态规划都涉及网格。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】近似算法</title>
    <link href="/2019/03/13/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/"/>
    <url>/2019/03/13/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h1><p>NP完全问题的定义就是以难解著称的问题，如旅行商问题和集合覆盖问题。很多人认为不可能编出快速解决这类问题的算法。</p><p>NP完全问题有以下几个特点：</p><ul><li>元素较少时算法运行速度非常快，随着元素增加，要考虑的情况急速增多，运行速度非常慢。</li><li>涉及“所有组合”的问题通常是NP完全问题。</li><li>不能将问题分成小问题，必须考虑各种可能的情况，这是通常是NP完全问题。</li><li>问题涉及序列且难以解决，可能是NP完全问题。</li><li>问题涉及集合且难以解决，可能是NP完全问题。</li><li>问题可转换为集合覆盖问题和旅行商问题，肯定是NP完全问题。</li></ul><p>虽然不能完美得解决这类问题，但是可以优秀得解决这类问题。通常使用的算法就是<strong>近似算法</strong>。</p><a id="more"></a><h1 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h1><p>贪婪算法是一种比较典型的<strong>近似算法</strong>。</p><p>原理很简单：</p><ol><li>找出最合适的。</li><li>找出第二合适的。</li><li>直到不能满足限定要求</li></ol><h1 id="集合覆盖问题"><a href="#集合覆盖问题" class="headerlink" title="集合覆盖问题"></a>集合覆盖问题</h1><p>如果有几个广播站可以覆盖一些地区，可能有重合，如何用最少的广播站覆盖最多的地区？</p><p>使用贪婪算法可以得到非常近似最优解的解。</p><ol><li>选出一个广播台，它覆盖了最多未覆盖的州。即使这个广播台覆盖了一些已经覆盖的州也没关系。</li><li>重复第一步。</li></ol><p>算法运行时间为O(n^2), n为广播台数量。</p><h2 id="代码表现"><a href="#代码表现" class="headerlink" title="代码表现"></a>代码表现</h2><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># coding: utf-8</span>states_needed <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"mt"</span><span class="token punctuation">,</span><span class="token string">"wa"</span><span class="token punctuation">,</span><span class="token string">"or"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token punctuation">,</span><span class="token string">"nv"</span><span class="token punctuation">,</span><span class="token string">"ut"</span><span class="token punctuation">,</span><span class="token string">"ca"</span><span class="token punctuation">,</span><span class="token string">"az"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># 输入所有地区</span>stations <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">#用散列表表示电台</span>stations<span class="token punctuation">[</span><span class="token string">"kone"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"id"</span><span class="token punctuation">,</span><span class="token string">"nv"</span><span class="token punctuation">,</span><span class="token string">"ut"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">#将数组转换为集合</span>stations<span class="token punctuation">[</span><span class="token string">"ktwo"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"wa"</span><span class="token punctuation">,</span><span class="token string">"id"</span><span class="token punctuation">,</span><span class="token string">"mt"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>stations<span class="token punctuation">[</span><span class="token string">"kthree"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"or"</span><span class="token punctuation">,</span><span class="token string">"nv"</span><span class="token punctuation">,</span><span class="token string">"ca"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>stations<span class="token punctuation">[</span><span class="token string">"kfour"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"nv"</span><span class="token punctuation">,</span><span class="token string">"ut"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>stations<span class="token punctuation">[</span><span class="token string">"kfive"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"ca"</span><span class="token punctuation">,</span><span class="token string">"az"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>final_station <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#最终选择广播台</span><span class="token keyword">while</span> states_needed<span class="token punctuation">:</span>    best_station <span class="token operator">=</span> <span class="token boolean">None</span>    states_covered <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> station<span class="token punctuation">,</span> states <span class="token keyword">in</span> stations<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        covered <span class="token operator">=</span> states_needed <span class="token operator">&amp;</span> states <span class="token comment"># 计算交集</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>covered<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin">len</span><span class="token punctuation">(</span>states_covered<span class="token punctuation">)</span><span class="token punctuation">:</span>            best_station <span class="token operator">=</span> station            states_covered <span class="token operator">=</span> covered    states_needed <span class="token operator">-=</span> states_covered <span class="token comment">#剔除覆盖的地区</span>    final_station<span class="token punctuation">.</span>add<span class="token punctuation">(</span>best_station<span class="token punctuation">)</span><span class="token keyword">print</span> final_station</code></pre><p>得到结果<code>set([&#39;ktwo&#39;, &#39;kthree&#39;, &#39;kone&#39;, &#39;kfive&#39;])</code></p>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
      <tag>近似算法</tag>
      
      <tag>最适化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】狄克斯特拉算法</title>
    <link href="/2019/03/12/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/"/>
    <url>/2019/03/12/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>广度优先搜索可以寻找到不带权值的最短路径，但是路径带权值的话就不可以使用广度优先搜索找最短路径了，所以我们使用狄克斯特拉算法算法来解决带权值的最短路径问题。  </p><p>具体算法步骤如下：</p><ol><li>找出最便宜的节点，即可在最短时间内前往的节点。</li><li>对于该节点的邻居，检查是否有前往它们的最短路径，如果有，就更新其开销。</li><li>重复这个过程，直到堆图中每个节点都这样做了。</li><li>计算最终路径。</li></ol><p><strong>注意</strong>：狄克斯特拉算法只支持<strong>有向无环图</strong>。当边的权值有负数时，也不可以使用狄克斯特拉算法。</p><a id="more"></a><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p>解决这个问题需要三个散列表，一个保存图的结构，一个保存最小开销，一个保存父节点。</p><p>具体代码如下：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># coding: utf-8</span><span class="token comment"># 将图用散列表表示</span>graph <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>graph<span class="token punctuation">[</span><span class="token string">"start"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>graph<span class="token punctuation">[</span><span class="token string">"start"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6</span>graph<span class="token punctuation">[</span><span class="token string">"start"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>graph<span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>graph<span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"fin"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>graph<span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>graph<span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>graph<span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"fin"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span>graph<span class="token punctuation">[</span><span class="token string">"fin"</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">#将最小开销用散列表表示</span>infinity <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span>costs <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>costs<span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6</span>costs<span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>costs<span class="token punctuation">[</span><span class="token string">"fin"</span><span class="token punctuation">]</span> <span class="token operator">=</span> infinity<span class="token comment">#将父节点用散列表表示</span>parents <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>parents<span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"start"</span>parents<span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"start"</span>parents<span class="token punctuation">[</span><span class="token string">"fin"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">None</span>processed <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">#标记处理过的节点</span><span class="token keyword">def</span> <span class="token function">find_lowest_cost_node</span><span class="token punctuation">(</span>costs<span class="token punctuation">)</span><span class="token punctuation">:</span>    lowest_cost <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span>    lowest_cost_node <span class="token operator">=</span> <span class="token boolean">None</span>    <span class="token keyword">for</span> node <span class="token keyword">in</span> costs<span class="token punctuation">:</span> <span class="token comment"># 遍历所有节点</span>        cost <span class="token operator">=</span> costs<span class="token punctuation">[</span>node<span class="token punctuation">]</span>        <span class="token keyword">if</span> cost <span class="token operator">&lt;</span> lowest_cost <span class="token keyword">and</span> node <span class="token keyword">not</span> <span class="token keyword">in</span> processed<span class="token punctuation">:</span> <span class="token comment">#如果该节点开销更低且没处理过</span>            lowest_cost <span class="token operator">=</span> cost <span class="token comment"># 将其作为开销最低的节点</span>            lowest_cost_node <span class="token operator">=</span> node    <span class="token keyword">return</span> lowest_cost_nodenode <span class="token operator">=</span> find_lowest_cost_node<span class="token punctuation">(</span>costs<span class="token punctuation">)</span><span class="token comment">#在未处理的节点中找到开销最小的节点</span><span class="token keyword">while</span> node <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span> <span class="token comment"># 循环在所有节点被处理后结束</span>    cost <span class="token operator">=</span> costs<span class="token punctuation">[</span>node<span class="token punctuation">]</span>    neighbors <span class="token operator">=</span> graph<span class="token punctuation">[</span>node<span class="token punctuation">]</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> neighbors<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 遍历当前节点的所有邻居</span>        new_cost <span class="token operator">=</span> cost <span class="token operator">+</span> neighbors<span class="token punctuation">[</span>n<span class="token punctuation">]</span>        <span class="token keyword">if</span> costs<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">></span> new_cost<span class="token punctuation">:</span> <span class="token comment"># 如果当前节点开销更小</span>            costs<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> new_cost <span class="token comment"># 更新邻居开销</span>            parents<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> node <span class="token comment"># 将该邻居父节点设为当前节点</span>    processed<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token comment"># 标记用过的节点</span>    node <span class="token operator">=</span> find_lowest_cost_node<span class="token punctuation">(</span>costs<span class="token punctuation">)</span><span class="token keyword">print</span> parents<span class="token keyword">print</span> costs</code></pre><p>得到结果：</p><pre class="language-none"><code class="language-none">&#123;&#39;a&#39;: &#39;b&#39;, &#39;b&#39;: &#39;start&#39;, &#39;fin&#39;: &#39;a&#39;&#125;&#123;&#39;a&#39;: 5, &#39;b&#39;: 2, &#39;fin&#39;: 6&#125;</code></pre><table><thead><tr><th align="center">子节点</th><th align="center">父节点</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">b</td></tr><tr><td align="center">b</td><td align="center">start</td></tr><tr><td align="center">fin</td><td align="center">a</td></tr></tbody></table><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>广度优先搜索用于在非加权图中查找最短路径。</li><li>狄克斯特拉算法用于在加权图中查找最短路径。</li><li>仅当权重为正时狄克斯特拉算法才管用。</li><li>如果图中包含负权边，请使用贝尔曼-福德算法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】广度优先搜索</title>
    <link href="/2019/03/06/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2019/03/06/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>广度优先搜索可以回答两类问题：</p><ol><li>从节点A出发，有前往节点B的路径吗？</li><li>从节点A出发，前往节点B哪条路径最短？</li></ol><a id="more"></a><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>广度优先算法通过<strong>队列</strong>来实现，<strong>队列是一种先进先出结构</strong>。具体操作如下：</p><ol><li>先将图用散列表表示</li><li>创建队列，将所有邻居都加入到队列当中。</li><li>从第一层邻居关系开始搜索，直到所有邻居都搜索完。</li><li>返回结果</li></ol><h1 id="代码表现"><a href="#代码表现" class="headerlink" title="代码表现"></a>代码表现</h1><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># coding: utf-8</span><span class="token keyword">from</span> collections <span class="token keyword">import</span> dequegraph <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>graph<span class="token punctuation">[</span><span class="token string">"you"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"alice"</span><span class="token punctuation">,</span><span class="token string">"bob"</span><span class="token punctuation">,</span><span class="token string">"claire"</span><span class="token punctuation">]</span>graph<span class="token punctuation">[</span><span class="token string">"bob"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"anuj"</span><span class="token punctuation">,</span><span class="token string">"peggy"</span><span class="token punctuation">]</span>graph<span class="token punctuation">[</span><span class="token string">"alice"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"peggy"</span><span class="token punctuation">]</span>graph<span class="token punctuation">[</span><span class="token string">"claire"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"thom"</span><span class="token punctuation">,</span><span class="token string">"jonny"</span><span class="token punctuation">]</span>graph<span class="token punctuation">[</span><span class="token string">"anuj"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>graph<span class="token punctuation">[</span><span class="token string">"peggy"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>graph<span class="token punctuation">[</span><span class="token string">"thom"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>graph<span class="token punctuation">[</span><span class="token string">"jonny"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>    search_queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    search_queue <span class="token operator">+=</span> graph<span class="token punctuation">[</span>name<span class="token punctuation">]</span>    searched <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">#用于记录已经观察过的人</span>    <span class="token keyword">while</span> search_queue<span class="token punctuation">:</span>        person <span class="token operator">=</span> search_queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> person <span class="token keyword">not</span> <span class="token keyword">in</span> searched<span class="token punctuation">:</span>            <span class="token keyword">if</span> person_is_seller<span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">print</span> person <span class="token operator">+</span> <span class="token string">"is a mango seller"</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                search_queue <span class="token operator">+=</span> graph<span class="token punctuation">[</span>person<span class="token punctuation">]</span>                searched<span class="token punctuation">.</span>append<span class="token punctuation">(</span>person<span class="token punctuation">)</span>  <span class="token comment">#标记这个人已经检查过</span>    <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token keyword">def</span> <span class="token function">person_is_seller</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> name<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'m'</span>search<span class="token punctuation">(</span><span class="token string">"you"</span><span class="token punctuation">)</span></code></pre><h1 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h1><p>广度优先沿着每条边前行，然后将每个人加入队列中检查，所以运行时间为O(边数+人数)，通常写做O(V+E)。</p>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】散列表</title>
    <link href="/2019/03/03/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <url>/2019/03/03/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><p>当要快速查找一样水果的价格时，可以用前面所学的二分查找来进行查找，但是二分查找的运行时间虽然为O(log n)但是总归会随着元素数量增加而拖慢查找速度。</p><p>所以数据结构中引入了<strong>散列表</strong>,散列表的运行时间始终为O(1)，是比较理想的数据存储方式。</p><a id="more"></a><p>散列表的数据存储原理如下：</p><ol><li>创建一个合适的空数组。</li><li>将输入的值用链表的方式加入数组中。</li><li>如果散列表中<strong>填装因子</strong>过大，则扩大数组（一般扩大两倍）。</li></ol><p>以上所说的<strong>填装因子</strong>为：（散列表包含的元素数/位置总数）一般填装因子临界值设置为0.7。</p><p>回到一开始的问题，假如苹果价钱是0.67，牛奶的价格是1.49，鳄梨价格是1.49，要快速查找各个水果价格可以用散列表。</p><p>虽然散列表自己实现比较难，但是任何主流语言都提供了散列表的实现，python提供的散列表实现为<strong>字典</strong>。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>book <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>book<span class="token punctuation">[</span><span class="token string">"apple"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0.67</span><span class="token operator">>></span><span class="token operator">></span>book<span class="token punctuation">[</span><span class="token string">"milk"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1.49</span><span class="token operator">>></span><span class="token operator">></span>book<span class="token punctuation">[</span><span class="token string">"avocado"</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1.49</span><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">print</span> book</code></pre><p>如果要查询鳄梨的价格，我们只需输入<code>print book[&quot;avocado&quot;]</code>即可。</p><h1 id="散列表的应用"><a href="#散列表的应用" class="headerlink" title="散列表的应用"></a>散列表的应用</h1><h2 id="用于查找"><a href="#用于查找" class="headerlink" title="用于查找"></a>用于查找</h2><p>手机内置电话簿就可使用散列表实现，具体实现代码如下：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>phone_book <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#亦可使用phone_book = &#123;&#125;</span><span class="token operator">>></span><span class="token operator">></span>phone_book<span class="token punctuation">[</span><span class="token string">"jenny"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">8675309</span><span class="token operator">>></span><span class="token operator">></span>phone_book<span class="token punctuation">[</span><span class="token string">"emergency"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">110</span></code></pre><p>现在要查找jenny的电话号码，只需输入<code>print phone_book[&quot;jenny&quot;]</code>即可得出jenny的电话号。</p><p>还有DNS解析也使用了散列表。</p><h2 id="防止重复"><a href="#防止重复" class="headerlink" title="防止重复"></a>防止重复</h2><p>投票中，要知道一个人是否已经投过票需要查找一串长长的名单，但是运用散列表就可以很快的查处一个人是否已经投过票。</p><pre class="language-python" data-language="python"><code class="language-python">voted <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">def</span> <span class="token function">check_voter</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> voted<span class="token punctuation">.</span>get<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> <span class="token string">"kick him out!"</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        voted<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>        <span class="token keyword">print</span> <span class="token string">"let him vote!"</span>check_voter<span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span>check_voter<span class="token punctuation">(</span><span class="token string">"mike"</span><span class="token punctuation">)</span>check_voter<span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span></code></pre><p>输出结果为：</p><pre class="language-result" data-language="result"><code class="language-result">let him vote!let him vote!kick him out!</code></pre><p>如果存储在列表中，运用简单查找速度将非常慢，存储在散列表中，查询速度非常快。</p><h2 id="用于缓存"><a href="#用于缓存" class="headerlink" title="用于缓存"></a>用于缓存</h2><p>当你第一次进入网页时，服务器需要做大量的查找工作，如果每次进网页都交由服务器处理，那么服务器将不堪重负，所以当你第一次进入网页中时，服务器处理后会生成一个散列表在缓存上，当你再次进入相同的页面时，就不用通过服务器处理，直接调用散列表中的缓存的数据就可以快速访问网页，大大提高了服务器的运行效率。</p><p>具体代码如下：</p><pre class="language-python" data-language="python"><code class="language-python">cache <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">def</span> <span class="token function">get_page</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">if</span> cache<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">return</span> cache<span class="token punctuation">[</span>url<span class="token punctuation">]</span><span class="token keyword">else</span><span class="token punctuation">:</span>data <span class="token operator">=</span> get_data_from_server<span class="token punctuation">(</span>url<span class="token punctuation">)</span>cache<span class="token punctuation">[</span>url<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token keyword">return</span> data</code></pre><h1 id="散列表性能"><a href="#散列表性能" class="headerlink" title="散列表性能"></a>散列表性能</h1><p>根据散列表特性，最好的情况为O(1),最坏的情况为O(n),所以当填装因子过大时，为了防止<strong>冲突</strong>，我们需要对散列表进行扩容，虽然调整散列表长度开销很大，但是就整体而言，散列表的整体运行时间依然是O(1)。</p><h1 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h1><p>散列函数作为非基础模块，本章不做解释，具体可以了解SHA函数和MD5算法。</p>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】快速排序</title>
    <link href="/2019/03/02/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/03/02/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h1><p>假如有一块长方形土地，要将土地均匀分成方块，而且方块要尽可能大，如何分呢？</p><p><strong>D&amp;C策略</strong></p><ol><li>找出长方形地块的宽作为分割出正方形的边长，分割出正方形。</li><li>剩下来不能分割的部分继续用第一步进行分割。</li><li>直到能分割成全部正方形。</li><li>返回结果，结束程序。</li></ol><p>此问题中基线条件为<strong>一条边长度是另一条边的整数倍</strong>。</p><a id="more"></a><p><strong>D&amp;C原理</strong></p><ol><li>找出简单的基线条件</li><li>确定如何缩小问题规模，使其符合基线条件。</li></ol><p>再来看一个问题，<strong>求2+4+6的和</strong>。</p><ol><li>找出基线条件。此问题的基线条件是<strong>数组中只包含一个数字</strong>，则计算容易许多。</li><li>将sum([2,4,6])的第一个数拆分出来，变为2+sum([4,6])</li><li>重复第二步，直到sum()中只有一个元素。</li><li>在调用栈中返回结果。</li><li>结束。</li></ol><p>代码表现为：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sum</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">2</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span></code></pre><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序也运用了D&amp;C，其原理如下：</p><ol><li>找出其中一个数，拿左右相邻数与这个数比较，把所有小于基准值的放到左边，大于基准值的放到右边。</li><li>左边和右边同时重复第一步。</li><li>直到数组长度为1</li><li>调用栈返回值。</li><li>结束程序。</li></ol><p>代码表现如下：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">quicksort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token comment">#基线条件</span>        <span class="token keyword">return</span> array    <span class="token keyword">else</span><span class="token punctuation">:</span>        pivot <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        less <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token keyword">if</span> i <span class="token operator">&lt;=</span> pivot<span class="token punctuation">]</span> <span class="token comment">#由所有小于等于基准值组成的子数组</span>        greater <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token keyword">if</span> i <span class="token operator">></span> pivot<span class="token punctuation">]</span> <span class="token comment">#由所有大于基准值组成的子数组</span>        <span class="token keyword">return</span> quicksort<span class="token punctuation">(</span>less<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">[</span>pivot<span class="token punctuation">]</span> <span class="token operator">+</span> quicksort<span class="token punctuation">(</span>greater<span class="token punctuation">)</span><span class="token keyword">print</span> quicksort<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】递归和栈</title>
    <link href="/2019/03/01/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%80%92%E5%BD%92%E5%92%8C%E6%A0%88/"/>
    <url>/2019/03/01/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%80%92%E5%BD%92%E5%92%8C%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>如果有一个盒子，盒子里有盒子，盒子里的盒子也有盒子，那么，怎样在一堆盒子里找出钥匙呢？</p><p><strong>方法一</strong>  </p><ol><li>创建一个要找的盒子堆。</li><li>从盒子里找出一个盒子，打开。</li><li>如果是盒子，就放入盒子堆，以后再查找。</li><li>如果是钥匙，结束返回。</li><li>回到第二步。</li></ol><a id="more"></a><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">look_for_key</span><span class="token punctuation">(</span>main_box<span class="token punctuation">)</span><span class="token punctuation">:</span>    pile <span class="token operator">=</span> main_box<span class="token punctuation">.</span>make_a_pile_to_look_through<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> pile <span class="token keyword">is</span> <span class="token keyword">not</span> empty<span class="token punctuation">:</span>        box <span class="token operator">=</span> pile<span class="token punctuation">.</span>grab_a_box<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> item <span class="token keyword">in</span> box<span class="token punctuation">:</span>            <span class="token keyword">if</span> item<span class="token punctuation">.</span>is_a_box<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                pile<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">)</span>            <span class="token keyword">elif</span> item<span class="token punctuation">.</span>is_a_key<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">print</span> <span class="token string">"find the key!"</span></code></pre><p><strong>方法二</strong></p><ol><li>检查盒子里面东西。</li><li>如果是盒子，返回第一步。</li><li>如果是钥匙，结束返回。</li></ol><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">look_for_key</span><span class="token punctuation">(</span>box<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> item <span class="token keyword">in</span> box<span class="token punctuation">:</span>        <span class="token keyword">if</span> item<span class="token punctuation">.</span>is_a_box<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">#递归条件</span>            look_for_key<span class="token punctuation">(</span>item<span class="token punctuation">)</span>        <span class="token keyword">elif</span> item<span class="token punctuation">.</span>is_a_key<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment">#基线条件</span>            <span class="token keyword">print</span> <span class="token string">"find the key!"</span></code></pre><p>第二种方法就使用了递归，自己调用自己。</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>一个简单函数：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">greet</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span> <span class="token string">"hello,"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"!"</span>greet2<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token string">"greeting ready to say bye..."</span>bye<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>这个函数调用了两个函数，两个函数代码如下：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">greeet2</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span> <span class="token string">"how are you,"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"?"</span><span class="token keyword">def</span> <span class="token function">bye</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span> <span class="token string">"ok bye!"</span></code></pre><p>在内存中，这个函数运行过程如下：</p><ol><li>greet()被压入栈底部。</li><li>greet2()被压入greet()上方。</li><li>打印出greet2()结果。</li><li>在栈中弹出greet2()。</li><li>bye()被压入greet()上方。</li><li>打印出bye()结果。</li><li>greet()返回。</li></ol><p>这个栈用于存储多个函数的变量，被称为<strong>调用栈</strong>。所有函数调用都进入调用栈。</p><h1 id="递归调用栈"><a href="#递归调用栈" class="headerlink" title="递归调用栈"></a>递归调用栈</h1><p>给定函数factorial(5)写做5!=5*4*3*2*1，那么：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fact</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token keyword">return</span> x<span class="token operator">*</span>fact<span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>fact(3)的调用栈变化如下：</p><ol><li>搭积木，最下层放入x=3，其上依次为x=2，x=1。</li><li>x=1满足结束条件，返回1，并弹出x=1的栈。</li><li>返回2*1，弹出x=2的栈。</li><li>返回3*2，结束程序。</li></ol><p>栈使用理解方便，但是占用内存大。栈太高时，可以转用循环。</p>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】选择排序</title>
    <link href="/2019/02/28/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/02/28/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="算法表现"><a href="#算法表现" class="headerlink" title="算法表现"></a>算法表现</h1><p>选择排序是基础排序算法，运行时间较长，具体算法表现如下：</p><ol><li><strong>遍历整个数组</strong>，找出最大（最小）值，弹出原数组并将其放入新数组中。</li><li><strong>遍历剩余元素</strong>，找出最大（最小）值，弹出原数组并放入新数组中前一个数之后。</li><li>重复第二步，得到新数组，排序完成。</li></ol><a id="more"></a><h1 id="代码表现"><a href="#代码表现" class="headerlink" title="代码表现"></a>代码表现</h1><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">findSmallest</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    Smallest <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    Smallest_index <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> Smallest<span class="token punctuation">:</span>            Smallest <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            Smallest_index <span class="token operator">=</span> i    <span class="token keyword">return</span> Smallest_index<span class="token keyword">def</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    newArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        smallest <span class="token operator">=</span> findSmallest<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        newArr<span class="token punctuation">.</span>append<span class="token punctuation">(</span>arr<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>smallest<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#append()给新数组添加元素，pop()将该元素弹出原数组</span>    <span class="token keyword">return</span> newArr<span class="token keyword">print</span> selectionSort<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h1 id="算法运行时间"><a href="#算法运行时间" class="headerlink" title="算法运行时间"></a>算法运行时间</h1><p>第一次需要检查n个元素，随后依次是n-1，n-2，···，2和1。因此运行时间为O(n*1/2*n)，但是大O表示法常常省略1/2这样的常数，所以选择排序的算法运行时间为O(n^2).</p>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法图解】二分查找</title>
    <link href="/2019/02/27/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2019/02/27/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="算法表现"><a href="#算法表现" class="headerlink" title="算法表现"></a>算法表现</h1><p>二分查找是计算机学习中比较基础的算法，具体算法表现如下：</p><ol><li><strong>排序</strong>，将要查找的一串数字从小到大或者从大到小进行排序。</li><li><strong>寻找该数字位置</strong>，取出正中间的数字，与要查找的数字比大小，大了就扔掉后面的一串数字，小了就扔掉前面的一串数字</li><li>重复第二步，直到找到想要的数字。</li></ol><a id="more"></a><h1 id="代码表现"><a href="#代码表现" class="headerlink" title="代码表现"></a>代码表现</h1><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">binary_search</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">list</span><span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span> <span class="token builtin">list</span>    low <span class="token operator">=</span> <span class="token number">0</span>    high <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> low <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>        guess <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">[</span>mid<span class="token punctuation">]</span>        <span class="token keyword">if</span>  guess <span class="token operator">==</span> item<span class="token punctuation">:</span>            <span class="token keyword">return</span> mid        <span class="token keyword">if</span> guess <span class="token operator">></span> item<span class="token punctuation">:</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">return</span> <span class="token boolean">None</span>my_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token keyword">print</span> binary_search<span class="token punctuation">(</span>my_list<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span> binary_search<span class="token punctuation">(</span>my_list<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><h1 id="算法运行时间"><a href="#算法运行时间" class="headerlink" title="算法运行时间"></a>算法运行时间</h1><p><strong>大O表示法</strong>，O表示的是操作数</p><ul><li>O(log n),对数时间，比如二分查找</li><li>O(n),线性时间，比如简单查找</li><li>O(n*logn)，快速排序</li><li>O(n^2)，选择排序</li><li>O(n!)，旅行商问题解决方法</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法图解学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【network实践】DHCP和NAT</title>
    <link href="/2018/12/17/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9ADHCP%E5%92%8CNAT/"/>
    <url>/2018/12/17/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9ADHCP%E5%92%8CNAT/</url>
    
    <content type="html"><![CDATA[<h1 id="DHCP概要"><a href="#DHCP概要" class="headerlink" title="DHCP概要"></a>DHCP概要</h1><p>DHCP(dynamic host configuration protocol)是局域网中的一种协议，可以给内部网自动分配ip地址。  </p><p>DHCP客户端和DHCP服务器之间连接过程分为四步：  </p><ol><li>discovery阶段：客户端通过broadcast寻找服务器</li><li>offer阶段：服务器预约ip地址并回信给客户端</li><li>request阶段：客户端收到offer，并将需要的ip地址，broadcast告诉服务器</li><li>ack阶段：服务器按照要求给客户端分配ip地址</li></ol><a id="more"></a><h1 id="NAT概要"><a href="#NAT概要" class="headerlink" title="NAT概要"></a>NAT概要</h1><p>NAT(network address translation)相当于在外部的网络记住内部网络的网络端口，从而可以在ip地址一直变化的情况下做到准确运输数据包。  </p><p><strong>NAT有两个优点：</strong>  </p><ol><li>可以解决ipv4地址枯竭的问题。</li><li>可以提高网络的安全性。</li></ol><p><strong>几个需要注意的NAT用语：</strong></p><ul><li>内部local address：从内部往内部看ip地址。</li><li>内部global address：从外部向内部看ip地址。</li><li>外部local address：从内部看外部的ip地址。</li><li>外部global address：从外部看外部的ip地址。</li></ul><p>NAT内部local address和内部global address是一一对应的关系：  </p><ul><li>10.1.1.1 – 1.1.1.1</li><li>10.1.1.2 – 1.1.1.2</li><li>10.1.1.3 – 1.1.1.3</li><li>10.1.1.4 – 1.1.1.4</li></ul><h1 id="PAT概要"><a href="#PAT概要" class="headerlink" title="PAT概要"></a>PAT概要</h1><p>PAT(port address translation)是局域网中的一种协议，与NAT不同的是，PAT可以就一个ip地址通过分配不同的网口的形式，实现只用一个内部global address分配到不同的内部local address。</p><ul><li>10.1.1.1:1025 – 1.1.1.1:1025</li><li>10.1.1.2:1029 – 1.1.1.1:1029</li><li>10.1.1.5:1030 – 1.1.1.1:1030</li></ul><h1 id="演习"><a href="#演习" class="headerlink" title="演习"></a>演习</h1><p>network拓扑图如下,要求用两台router，一台switch完成实验，从ISP路由器出发分割出的global地址是209.165.200.224/29，利用此global地址设定GW路由器的PAT，内部IP地址根据192.168.32.0/24的范围进行DHCP分配地址,PC取得适当的ip地址后，模拟网络服务(loopback)能完成通信的话就是成功。</p><p><img src="/images/DHCP.jpg">  </p><p><strong>首先配置GW的路由器NAT：</strong></p><pre class="language-C" data-language="C"><code class="language-C">GW_Router(config)#interface fastethernet 0GW_Router(config-if)#ip address 192.168.32.254 255.255.255.0GW_Router(config-if)#ip nat insideGW_Router(config-if)#no shutdownGW_Router(config)#interface fastethernet 1GW_Router(config-if)#ip address 209.165.201.18 255.255.255.0GW_Router(config-if)#ip nat outsideGW_Router(config-if)#no shutdownGW_Router(config)#ip nat pool DPAT 209.165.201.209 209.165.201.230 netmask 255.255.255.0GW_Router(config)#access-list 1 permit host 192.168.32.0  &#x2F;&#x2F;设置ACLGW_Router(config)#ip nat inside source list 1 pool DPAT overload &#x2F;&#x2F;PAT定义</code></pre><p><strong>其次配置GW路由器DHCP：</strong></p><pre class="language-C" data-language="C"><code class="language-C">GW_Router(config)#ip dhcp excluded-address 192.168.32.10 192.168.32.254&#x2F;&#x2F;192.168.32.10-254除外GW_Router(config)#ip dhcp pool LANUserGW_Router(dhcp-config)#network 192.168.32.0 255.255.255.0GW_Router(dhcp-config)#default-router 192.168.32.254GW_Router(dhcp-config)#domain-name google.comGW_Router(dhcp-config)#dns-server 8.8.8.8 &#x2F;&#x2F;设定dns服务器GW_Router(dhcp-config)#lease 0 12 &#x2F;&#x2F;释放时间设置为12小时GW_Router(config)#ip route 0.0.0.0 0.0.0.0 209.165.201.17&#x2F;&#x2F;设定GW路由到ISP路由的默认路由通路</code></pre><p><strong>接着配置ISP服务器：</strong></p><pre class="language-C" data-language="C"><code class="language-C">ISP_Router(config)#interface fastethernet 0ISP_Router(config-if)#ip address 209.165.201.17 255.255.255.0ISP_Router(config-if)#no shutdownISP_Router(config)#interface loopback 0ISP_Router(config-if)#ip address 8.8.8.8 255.255.255.0ISP_Router(config)#ip route 209.165.200.224 255.255.255.248 209.165.201.18ISP_Router#show ip route</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此所有NAT配置完成，但是最终<code>show ip nat translations</code>什么也不显示，原因是设置完后没有运行，这时用PC<code>ping 8.8.8.8</code>就可以查看设置是否成功，<code>show ip nat translations</code>也会显示内容。  </p><p>有一个小疑问<code>GW_Router(config)#ip route 0.0.0.0 0.0.0.0 209.165.201.17</code>这个语句为什么是从default gateway出发？</p>]]></content>
    
    
    <categories>
      
      <category>network实践笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>cisco</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【network实践】access和trunk配置</title>
    <link href="/2018/12/06/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9Aaccess%E5%92%8Ctrunk%E9%85%8D%E7%BD%AE/"/>
    <url>/2018/12/06/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9Aaccess%E5%92%8Ctrunk%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="access"><a href="#access" class="headerlink" title="access"></a>access</h1><p>当Switch划分成几个不同的vlan时，怎样解决不同vlan内部的通信问题呢？这时我们就需要access来帮助我们进行内部的通信，这样就可以在一台switch中划分出很多vlan，各个vlan之间相互隔离不能通信。<br><strong>access只能解决同网段同vlan的互通问题，不能解决不同网段的vlan互通问题</strong> ，比如192.168.1.1和192.168.2.1即使被access划分进了一个vlan也不能相互通信。</p><a id="more"></a><h2 id="access演习"><a href="#access演习" class="headerlink" title="access演习"></a>access演习</h2><p>将switch进行如下设置：</p><blockquote><ul><li>Fa 0/1 - 8 =&gt; VLAN 10</li><li>Fa 0/9 - 16 =&gt; VLAN 20</li><li>四台电脑之间通信确认</li></ul></blockquote><h3 id="配置SWITCH"><a href="#配置SWITCH" class="headerlink" title="配置SWITCH"></a>配置SWITCH</h3><pre class="language-C" data-language="C"><code class="language-C">Switch(config)#interface range fastethernet 0&#x2F;1 - 8Switch(config-if-range)#switchport mode accessSwitch(config-if-range)#switchport access vlan 10Switch(config)#interface range fastethernet 0&#x2F;9 - 16Switch(config-if-range)#switchport mode accessSwitch(config-if-range)#switchport access vlan 20</code></pre><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>至此access配置完成，结果是vlan10接口之间可以相互通信，vlan20接口之间可以相互通信，vlan10接口与vlan20接口即使切换成同一网段也无法实现通信。</p><h1 id="trunk"><a href="#trunk" class="headerlink" title="trunk"></a>trunk</h1><p>第一章我们解决了同一台switch之间不同vlan的划分，然而两台甚至多台switch如何解决通信呢？这就需要trunk来解决问题，trunk可以解决两台switch设置成同一vlan之间的通信问题。</p><h2 id="trunk演习"><a href="#trunk演习" class="headerlink" title="trunk演习"></a>trunk演习</h2><p>将两台switch进行如下设定：</p><ul><li>Fa 0/1 - 8 =&gt; VLAN 10</li><li>Fa 0/9 - 16 =&gt; VLAN 20</li><li>Fa 0/24 为trunk口</li><li>vlan10的PC分为192.168.10.1和192.168.10.2</li><li>vlan20的PC分为192.168.20.12和192.168.20.13</li><li>switchport通信确认<ul><li>switchport 1和switchport 2</li><li>switchport 1和switchport 13</li><li>switchport 12和switchport 13</li></ul></li></ul><h3 id="配置switch的access"><a href="#配置switch的access" class="headerlink" title="配置switch的access"></a>配置switch的access</h3><pre class="language-C" data-language="C"><code class="language-C">Switch(config)#interface range fastethernet 0&#x2F;1 - 8Switch(config-if-range)#switchport mode accessSwitch(config-if-range)#switchport access vlan 10Switch(config)#interface range fastethernet 0&#x2F;9 - 16Switch(config-if-range)#switchport mode accessSwitch(config-if-range)#switchport access vlan 20</code></pre><h3 id="配置trunk"><a href="#配置trunk" class="headerlink" title="配置trunk"></a>配置trunk</h3><pre class="language-C" data-language="C"><code class="language-C">SW1(config)#interface range fastethernet 0&#x2F;24SW1(config-if-range)#switchport trunk encapsulation dot1qSW1(config-if-range)#switchport nonegotiate</code></pre><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>两台switch之间vlan10和vlan20可以分别相互通信。</p>]]></content>
    
    
    <categories>
      
      <category>network实践笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>cisco</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【network实践】单臂路由的实现</title>
    <link href="/2018/12/05/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2018/12/05/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>vlan間ルーティング（ROUTER ON A STICK,单臂路由）在很多博客上都有记录，物理上的要实现两个不同网段的互联的拓扑图如下</p><a id="more"></a><p><img src="/images/%E6%BC%94%E4%B9%A01%E6%8B%93%E6%89%91%E5%9B%BE.jpg"><br>但是现在只需要一台路由器和一台switch通过access和trunk制造虚拟的网口就可实现两个不同网段在同一台switch上的互联。  </p><h2 id="演习"><a href="#演习" class="headerlink" title="演习"></a>演习</h2><p><img src="/images/%E6%BC%94%E4%B9%A01%E6%8B%93%E6%89%91%E5%9B%BE.jpg"><br>条件：</p><blockquote><ul><li>拓扑图如上所示</li></ul></blockquote><ul><li>建立单臂路由实现三个PC之间的相互通信</li></ul><p>Router设定</p><pre class="language-C" data-language="C"><code class="language-C">Router(config)#interface fastethernet 0.1Router(config-subif)#encapsulation dot1q 1Router(config-subif)#ip address 172.16.1.254 255.255.255.0Router(config-subif)#exitRouter(config)#interface fastethernet 0.10Router(config-subif)#encapsulation dot1q 10Router(config-subif)#ip address 172.16.10.254 255.255.255.0Router(config-subif)#exitRouter(config)#interface fastethernet 0.20Router(config-subif)#encapsulation dot1q 20Router(config-subif)#ip address 172.16.20.254 255.255.255.0Router(config-subif)#exitRouter(config)#interface fastethernet 0.99Router(config-subif)#encapsulation dot1q 99 nativeRouter(config-subif)#exitRouter(config)#interface fastethernet 0Router(config-if)#no shutdown</code></pre><p>switch设定</p><pre class="language-C" data-language="C"><code class="language-C">Switch(config)#vlan 10,20,99Switch(config-vlan)#exitSwitch(config)#interface range fastethernet 0&#x2F;1 - 3switch(config-if-range)#switchport mode accessSwitch(config-if-range)#interface fastethernet 0&#x2F;2Switch(config-if)#switchport access vlan 10Switch(config-if)#interface fastethernet 0&#x2F;3Switch(config-if)#switchport access vlan 20Switch(config-if)#interface fastethernet 0&#x2F;12Switch(config-if)#switchport trunk encapsulation dot1qSwitch(config-if)#switchport mode trunk&#x2F;&#x2F;Switch(config-if)#switchport nonegotiate  2950switch已经不需要这一步骤Switch(config-if)#switchport trunk native vlan 99Switch(config-if)#interface vlan 1Switch(config-if)#ip address 172.16.1.100 255.255.255.0Switch(config-if)#no shutdownSwitch(config-if)#exitSwitch(config)#ip default-gateway 172.16.1.254Switch(config)#exit</code></pre><h3 id="单臂路由的验证"><a href="#单臂路由的验证" class="headerlink" title="单臂路由的验证"></a>单臂路由的验证</h3><p>Router</p><pre class="language-C" data-language="C"><code class="language-C">Router#show ip interface [brief]Router#show ip routeRouter#show vlans</code></pre><p>Switch</p><pre class="language-C" data-language="C"><code class="language-C">Switch#show interfaces trunkSwitch#show interfaces switchportSwitch#show vlan [brief]Switch#show interfaces vlan &lt;vlan-id&gt;Switch#show run</code></pre><h3 id="演习结果"><a href="#演习结果" class="headerlink" title="演习结果"></a>演习结果</h3><p>switch端结果</p><pre class="language-C" data-language="C"><code class="language-C">Switch#show vlanVLAN Name                             Status    Ports---- -------------------------------- --------- -------------------------------1    default                          active    Fa0&#x2F;17, Fa0&#x2F;18, Fa0&#x2F;19, Fa0&#x2F;20                                                Fa0&#x2F;21, Fa0&#x2F;22, Fa0&#x2F;2310   VLAN0010                         active    Fa0&#x2F;1, Fa0&#x2F;2, Fa0&#x2F;4, Fa0&#x2F;5                                                Fa0&#x2F;6, Fa0&#x2F;7, Fa0&#x2F;820   VLAN0020                         active    Fa0&#x2F;3, Fa0&#x2F;9, Fa0&#x2F;10, Fa0&#x2F;11                                                Fa0&#x2F;12, Fa0&#x2F;13, Fa0&#x2F;14, Fa0&#x2F;15                                                Fa0&#x2F;1699   VLAN0099                         active1002 fddi-default                     active1003 token-ring-default               active1004 fddinet-default                  active1005 trnet-default                    activeVLAN Type  SAID       MTU   Parent RingNo BridgeNo Stp  BrdgMode Trans1 Trans2---- ----- ---------- ----- ------ ------ -------- ---- -------- ------ ------1    enet  100001     1500  -      -      -        -    -        0      010   enet  100010     1500  -      -      -        -    -        0      020   enet  100020     1500  -      -      -        -    -        0      099   enet  100099     1500  -      -      -        -    -        0      01002 fddi  101002     1500  -      -      -        -    -        0      01003 tr    101003     1500  -      -      -        -    -        0      01004 fdnet 101004     1500  -      -      -        ieee -        0      01005 trnet 101005     1500  -      -      -        ibm  -        0      0Remote SPAN VLANs------------------------------------------------------------------------------Primary Secondary Type              Ports------- --------- ----------------- ------------------------------------------</code></pre><pre class="language-C" data-language="C"><code class="language-C">Switch#show interface trunkPort        Mode         Encapsulation  Status        Native vlanFa0&#x2F;24      on           802.1q         trunking      1Port      Vlans allowed on trunkFa0&#x2F;24      1-4094Port        Vlans allowed and active in management domainFa0&#x2F;24      1,10,20,99Port        Vlans in spanning tree forwarding state and not prunedFa0&#x2F;24      1,10,20,99</code></pre><p>Router端结果</p><pre class="language-C" data-language="C"><code class="language-C">Router#show ip interface briefInterface                  IP-Address      OK? Method Status                Prot                                                                                                             ocolFastEthernet0              unassigned      YES NVRAM  up                    up                                                                                                               FastEthernet0.1            172.16.1.254    YES manual up                    up                                                                                                               FastEthernet0.10           172.16.10.254   YES manual up                    up                                                                                                               FastEthernet0.20           172.16.20.254   YES manual up                    up                                                                                                               FastEthernet0.99           unassigned      YES unset  up                    up                                                                                                               FastEthernet1              unassigned      YES NVRAM  up                    down                                                                                                             BRI0                       unassigned      YES NVRAM  administratively down down                                                                                                             BRI0:1                     unassigned      YES unset  administratively down down                                                                                                             BRI0:2                     unassigned      YES unset  administratively down down                                                                                                             FastEthernet2              unassigned      YES unset  up                    down                                                                                                             FastEthernet3              unassigned      YES unset  up                    down</code></pre><pre class="language-C" data-language="C"><code class="language-C">Router#show ip routeCodes: C - connected, S - static, R - RIP, M - mobile, B - BGP       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2       E1 - OSPF external type 1, E2 - OSPF external type 2       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2       ia - IS-IS inter area, * - candidate default, U - per-user static route       o - ODR, P - periodic downloaded static routeGateway of last resort is not set     172.16.0.0&#x2F;24 is subnetted, 3 subnetsC       172.16.20.0 is directly connected, FastEthernet0.20C       172.16.10.0 is directly connected, FastEthernet0.10C       172.16.1.0 is directly connected, FastEthernet0.1</code></pre><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>做完这个实验才理解了为什么单臂路由为什么在network里如此重要，也理解了为什么前两节课先生要那么大力气讲access和trunk的作用，通过路由器的虚拟网口，可以变相地将一台路由器当作多台使用（毕竟路由器那么贵），switch也变相承担了路由器的部分功能（switch相对便宜），但是虚拟网口是否能无限扩容并且实际体验是否能跟物理接续体验一致也是以后值得研究的课题。</p>]]></content>
    
    
    <categories>
      
      <category>network实践笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>cisco</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【network实践】标准ACL</title>
    <link href="/2018/12/04/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A0%87%E5%87%86ACL/"/>
    <url>/2018/12/04/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A0%87%E5%87%86ACL/</url>
    
    <content type="html"><![CDATA[<p>ACL(Access Control List)是进行网络通信识别控制中记录控制条件的一个表，在Router的interface中应用，与许可条件一致的话就可以通过，除此以外全部拒绝通信。  </p><a id="more"></a><p>标准acl list的号码可以是1〜99和1300〜1999，扩张acl list号码为100〜199和2000〜2699。</p><h2 id="演习"><a href="#演习" class="headerlink" title="演习"></a>演习</h2><p><img src="/images/%E6%A0%87%E5%87%86ACL.jpg"></p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><blockquote><ul><li>组成如图所示的网络并相互ping通</li></ul></blockquote><ul><li>192.168.1.0所属的PC能够和192.168.2.1通信</li><li>但是192.168.1.1拒绝通信</li></ul><p>配置路由器</p><pre class="language-C" data-language="C"><code class="language-C">Router(config)#interface fastethernet 0Router(config-if)#ip address 192.168.1.254 255.255.255.0Router(config-if)#no shutdownRouter(config)#interface fastethernet 1Router(config-if)#ip address 192.168.2.254 255.255.255.0Router(config-if)#no shutdownRouter#show interface 确认端口是否设置成功</code></pre><p>配置ACL</p><pre class="language-C" data-language="C"><code class="language-C">Router(config)#access-list 1 deny host 192.168.1.1Router(config)#access-list 1 permit anyRouter(config)#interface fastethernet 0Router(config-if)#ip access-group 1 inRouter#show access-lists  确认ACL创建成功</code></pre><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><blockquote><ul><li>PC B,PC C,PC D之间可以相互ping</li></ul></blockquote><ul><li>PC A和PC D不能ping成功</li></ul><p>如果选择Fa 1端口配置ACL的话，就修改成如下代码</p><pre class="language-C" data-language="C"><code class="language-C">Router(config)#interface fastethernet 1Router(config-if)#ip access-group 1 outRouter#show access-lists  确认ACL创建成功</code></pre><p>如果不需要这个ACL的话</p><pre class="language-C" data-language="C"><code class="language-C">Router(config)#no access-list 1</code></pre><p>就可以将ACL删去.</p><p>ACL的对照顺序是自上向下并且默认是deny的，如果将实验中ACL的两行互换在本演习中理论上没有影响，但是具体实验并没有实施，“顺序因素对ACL的影响”是以后可以考虑的问题点之一。</p>]]></content>
    
    
    <categories>
      
      <category>network实践笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>cisco</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【network实践】扩展ACL(二)</title>
    <link href="/2018/12/04/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%89%A9%E5%B1%95ACL%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2018/12/04/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%89%A9%E5%B1%95ACL%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="演习2"><a href="#演习2" class="headerlink" title="演习2"></a>演习2</h2><p> 与标准ACL不同，扩展ACL可以进行对送信元IP地址、宛先IP地址、プロトコル、送信元ポート、宛先ポート的控制来进行针对性的访问控制。  </p><a id="more"></a><p><img src="/images/%E6%BC%94%E4%B9%A01%E6%8B%93%E6%89%91%E5%9B%BE.jpg">  </p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol><li>网络拓扑图如图所示，首先PC之间互相ping通。  </li><li>从NW_A（192.168.1.0）到NW_B（192.168.2.0）的telnet拒绝，其他的数据包都可正常传输。</li></ol><p>配置路由器</p><pre class="language-C" data-language="C"><code class="language-C">Router(config)#interface fastethernet 0Router(config-if)#ip address 192.168.1.254 255.255.255.0Router(config-if)#no shutdownRouter(config)#interface fastethernet 1Router(config-if)#ip address 192.168.2.254 255.255.255.0Router(config-if)#no shutdownRouter#show interface   确认端口是否配置成功</code></pre><p>配置ACL </p><pre class="language-C" data-language="C"><code class="language-C">Router(config)#access-list 100 deny tcp host 192.168.1.1 host 192.168.2.1 eq 23  Router(config)#access-list 100 permit ip any anyRouter(config)#show access-lists 确认ACL是否建立成功Router(config)#interface fastethernet 0Router(config)#ip access-group 100 in</code></pre><p>配置switch</p><pre class="language-C" data-language="C"><code class="language-C">switch(config)#interface vlan 1switch(config-if)#ip address 192.168.1.100 255.255.255.0switch(config-if)#no shutdownswitch(config-if)#exitswitch(config)#ip default-gateway 192.168.1.254</code></pre><p>switch有两台，根据上述代码可以配置另一台  </p><p>配置router密码  </p><pre class="language-C" data-language="C"><code class="language-C">Router(config)#line vty 0 4Router(config-line)#password ciscoRouter(config-line)#loginRouter(config-line)#endRouter#show run 确认router密码是否配置成功</code></pre><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>最终结果为PCA无法telnet到PCB（显示访问拒绝），但是PCB可以telnet到PCA，电脑之间的互相ping正常。</p>]]></content>
    
    
    <categories>
      
      <category>network实践笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>cisco</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【network实践】扩展ACL(一)</title>
    <link href="/2018/12/03/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%89%A9%E5%B1%95ACL%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2018/12/03/network%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%89%A9%E5%B1%95ACL%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p> 与标准ACL不同，扩展ACL可以进行对送信元IP地址、宛先IP地址、プロトコル、送信元ポート、宛先ポート的控制来进行针对性的访问控制。</p><a id="more"></a><h2 id="演习1"><a href="#演习1" class="headerlink" title="演习1"></a>演习1</h2><p><img src="/images/%E6%BC%94%E4%B9%A01%E6%8B%93%E6%89%91%E5%9B%BE.jpg">  </p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol><li>整个网络要能互相ping通  </li><li>设置番号为100的扩展ACL，从PC A1到PC B1的数据包全部拒绝，其余都许可通信。</li></ol><p>首先配置路由器让其互相ping通  </p><pre class="language-C" data-language="C"><code class="language-C">Router(config)#interface fastethernet 0Router(config)#ip address 192.168.1.254 255.255.255.0Router(config)#no shutdownRouter(config)#interface fastethernet 1Router(config)#ip address 192.168.2.254 255.255.255.0Router(config)#no shutdownRouter#show interface   确认端口是否配置成功</code></pre><p>配置ACL</p><pre class="language-C" data-language="C"><code class="language-C">Router(config)#access-list 100 deny ip host 192.168.1.1 host 192.168.2.1Router(config)#access-list 100 permit ip any anyRouter(config)#show access-lists 确认ACL是否建立成功Router(config)#interface fastethernet 0Router(config)#ip access-group 100 in</code></pre><p>如果想设置Fa 1端口，就用</p><pre class="language-C" data-language="C"><code class="language-C">Router(config)#interface fastethernet 1  Router(config)#ip access-group 100 out</code></pre><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>最后检查结果时，会出现PCA1到PCB1到达不能，PCB1到PCA1出现timeout，这是正常结果，因为tcp/ip的三次握手中，当PCA1到PCB1通路阻断时，PCA1不能回应PCB1发出的“问候”，从而出现timeout。  </p>]]></content>
    
    
    <categories>
      
      <category>network实践笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>cisco</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
